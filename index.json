[{"authors":["admin"],"categories":null,"content":" 初出茅庐开发仔 拖延症晚期患者 熬夜不累早起难 云撸猫受益者 B 站白嫖大师  ","date":1565709649,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":1565709649,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://youngwilliamz.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":" 初出茅庐开发仔 拖延症晚期患者 熬夜不累早起难 云撸猫受益者 B 站白嫖大师  ","tags":null,"title":"YoungWilliam","type":"authors"},{"authors":null,"categories":null,"content":" 关于写本书的初衷 算法是程序员最核心的能力！\n主要是自己容易犯懒，喜欢去折腾一些有的没得，比如这个博客。开始这本书的时候，也就是现在，我已经大三结束了，暑假都快过完了。秋招都已经开始了。但我 LeetCode 只刷了十几道，感觉完全不够用，因此希望借此能够激励或者督促自己坚持下去，而不是三天晒网，两天打鱼。\n此书的目录 关于此书的目录是根据 LeetCode 官方的 Top Interview Questions 来的。当然中文版（算法面试题汇总）也有，不过中文版的题目还不够健全。\n我的刷题方式 本着快速刷题的宗旨，我不会在一题上面纠结很久，顶多 5 分钟就可以看答案了。因此，我会优先做有官方答案的题目，保证刷题的效率。\n","date":1565711906,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1565711906,"objectID":"1bf6a8ef4e1da6d00cb3969f598292c8","permalink":"https://youngwilliamz.github.io/note/leetcode/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/","section":"note","summary":"个人刷题笔记，欢迎指正，交流。","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":"自从 2018 年的那个暑假第一次接触 Docker 以来，几乎每个项目几乎都用到了 Docker。\n虽然我对 Docker 如此感兴趣，但一直没有深入去了解 Docker 底层的实现，因此我希望能够通过这本笔记，记录一下我学习 Docker 的过程以及最近打算手撸一个简易版本 Docker。\n","date":1565711906,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1565711906,"objectID":"5f5eb8b7625d291e649e30c17bc4ba0a","permalink":"https://youngwilliamz.github.io/note/docker/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/docker/","section":"note","summary":"？？？","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":" 题目 难度：易\n给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在众数。\n示例 1:\n输入: [3,2,3] 输出: 3  示例 2:\n输入: [2,2,1,1,1,2,2] 输出: 2  传送门：\n English 中文  思路    算法 时间复杂度 空间复杂度     暴力 O(n^2) O(n)   哈希表 O(n) O(n)   排序 O(nlogn) O(1)   分治 O(nlogn) O(logn)   Boyer-Moore 投票算法 O(n) O(1)    分治 一分为二，求两边众数的次数，很复杂。\nBoyer-Moore 投票算法 寻找数组中超过一半的数字，这意味着数组中其他数字出现次数的总和都是比不上这个数字出现的次数\n即如果把 该众数记为 +1 ，把其他数记为 −1 ，将它们全部加起来，和是大于 0 的。\n代码 大致操作：\n 设置两个变量 candidate 和 count，candidate 用来保存数组中遍历到的某个数字，count 表示当前数字的出现次数，一开始 candidate 保存为数组中的第一个数字，count 为 1\n 遍历整个数组\n 如果数字与之前 candidate 保存的数字相同，则 count 加 1\n 如果数字与之前 candidate 保存的数字不同，则 count 减 1\n 如果出现次数 count 变为 0 ，candidate 进行变化，保存为当前遍历的那个数字，并且同时把 count 重置为 1（这里是细节，同时也需要好好理解）\n 遍历完数组中的所有数字即可得到结果\n   参考：https://leetcode-cn.com/problems/two-sum/solution/du-le-le-bu-ru-zhong-le-le-ru-he-zhuang-bi-de-q\nclass Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int candidate = nums[0]; int counter = 1; for (int i = 1; i \u0026lt; nums.size(); i++) { if (nums[i] == candidate) { ++counter; } else { --counter; } if (counter == 0) { candidate = nums[i]; counter = 1; } } return candidate; } };  小结 这种题的最优解普通人的很难想到，既简单又高效，这个摩尔有点东西。果然还是得多刷题，不过这道题得注意一下细节。\n","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"382b24e6813157cbac13546544fb027d","permalink":"https://youngwilliamz.github.io/note/leetcode/array/169/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/array/169/","section":"note","summary":"题目 难度：易\n给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在众数。\n示例 1:\n输入: [3,2,3] 输出: 3  示例 2:\n输入: [2,2,1,1,1,2,2] 输出: 2  传送门：\n English 中文  思路    算法 时间复杂度 空间复杂度     暴力 O(n^2) O(n)   哈希表 O(n) O(n)   排序 O(nlogn) O(1)   分治 O(nlogn) O(logn)   Boyer-Moore 投票算法 O(n) O(1)    分治 一分为二，求两边众数的次数，很复杂。","tags":null,"title":"169. Majority Element 求众数","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"48a899d50d972161ba5e150886aecc65","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter1-array/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter1-array/","section":"note","summary":"","tags":null,"title":"Array 数组","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"43f1e8706065f42e36eaf79a959cc3e2","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter7/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter7/","section":"note","summary":"","tags":null,"title":"Desgin 设计","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"fa958d18da050146c970f7bc408b778b","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter6/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter6/","section":"note","summary":"","tags":null,"title":"Dynamic Programming 动态规划","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"a588b096bb3a08224ffaa56ba20150da","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter3/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter3/","section":"note","summary":"","tags":null,"title":"Linked List 链表","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"07feb7c771c04c4830bef02d418a7292","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter8/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter8/","section":"note","summary":"","tags":null,"title":"Math 数学","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"e020935897071ff02543f5e92b22f7e8","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter9/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter9/","section":"note","summary":"","tags":null,"title":"Others 其他","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"f067b0fc827090ba4dfe9a98e6f01965","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter5-sorting-searching/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter5-sorting-searching/","section":"note","summary":"","tags":null,"title":"Sorting \u0026 Searching 排序与搜索","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"2d84a6aeb462d462df74381fa1db397c","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter2/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter2/","section":"note","summary":"","tags":null,"title":"String 字符串","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"185d6601e310dc9a7104a541edd18013","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter4/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter4/","section":"note","summary":"","tags":null,"title":"Tree 树","type":"docs"},{"authors":["YoungWilliam"],"categories":[],"content":"","date":1565709649,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565709649,"objectID":"050f444fe2cac381168e37b5e0192f89","permalink":"https://youngwilliamz.github.io/project/opencredit/","publishdate":"2019-08-13T23:20:49+08:00","relpermalink":"/project/opencredit/","section":"project","summary":"基于 FISCO-BCOS 框架（继承以太坊技术体系）实现的去中心化征信系统。","tags":["Blockchain"],"title":"OpenCredit","type":"project"},{"authors":["YoungWilliam"],"categories":["学习"],"content":"","date":1565459386,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565459386,"objectID":"091404ffd6bf34f3231d751b33c3abac","permalink":"https://youngwilliamz.github.io/project/mydocker/","publishdate":"2019-08-11T01:49:46+08:00","relpermalink":"/project/mydocker/","section":"project","summary":"希望借此记录并学习 Docker 的内部构造","tags":["Docker"],"title":"从 0 实现 Docker","type":"project"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 为什么要有 /proc？ 想必在日常开发写查 BUG 中，你会经常用到像 top、ps 这样的 Linux 命令来查看进程、CPU 的状态吧。\n那你是否有想过：这些不都是内核才知道的吗？而作为身处 shell （用户态）的我们又是通过什么途径知道这些的呢？\n是有什么 system call 吗？是有什么高级的接口吗？\n不不不，其实是通过一个神奇的目录，也就是今天的主角 /proc。\n实际上，top 中的数据就是读取 /proc/stat 文件获得的，/proc/stat 文件被读取时会自动更新，从而 top 获得最新的 CPU 占用率情况。\n/proc 是什么？ /proc 其实不是一个“真正”的文件目录，而是一个“虚拟”的文件系统（virtual filesystem）。\n为什么是虚拟的呢？因为它不写入外存空间，只存在于内存中。\n它包含了系统运行时的信息，包括：\n 当前运行进程信息 系统内存 mount 设备信息 一些硬件配置 \u0026hellip;等。  因此，可以把它当作内核的信息中心。\n当然许多系统工具都是通过简单读取该目录下的某些内容。\n比如：\n lsmod = cat /proc/modules lspci = cat /proc/pci  在系统正在运行时，你甚至可以通过修改 /proc 目录下文件，来读取修改系统的内核参数（sysctl）。\n/proc 基本目录结构 因为文件都在内存中，如果你去看每个文件的大小，你会发现都是 0，除了 kcore, mtrr and self。\n当遍历这个目录的时候，会发现有些数字，这些都是为每个进程创建的空间，数字就是它们的 PID。\n[go_dev@0f8b372ed635 proc]$ ll /proc total 0 dr-xr-xr-x 9 go_dev go_dev 0 Aug 1 18:43 1 dr-xr-xr-x 9 go_dev go_dev 0 Aug 1 18:44 30 drwxrwxrwt 2 root root 40 Aug 1 18:43 acpi -r--r--r-- 1 root root 0 Aug 1 18:44 buddyinfo dr-xr-xr-x 4 root root 0 Aug 1 18:43 bus -r--r--r-- 1 root root 0 Aug 1 18:44 cgroups -r--r--r-- 1 root root 0 Aug 1 18:44 cmdline -r--r--r-- 1 root root 23709 Aug 1 18:44 config.gz -r--r--r-- 1 root root 0 Aug 1 18:44 consoles -r--r--r-- 1 root root 0 Aug 1 18:44 cpuinfo -r--r--r-- 1 root root 0 Aug 1 18:44 crypto -r--r--r-- 1 root root 0 Aug 1 18:44 devices -r--r--r-- 1 root root 0 Aug 1 18:44 diskstats -r--r--r-- 1 root root 0 Aug 1 18:44 dma dr-xr-xr-x 2 root root 0 Aug 1 18:44 driver -r--r--r-- 1 root root 0 Aug 1 18:44 execdomains -r--r--r-- 1 root root 0 Aug 1 18:44 fb -r--r--r-- 1 root root 0 Aug 1 18:44 filesystems dr-xr-xr-x 8 root root 0 Aug 1 18:43 fs -r--r--r-- 1 root root 0 Aug 1 18:44 interrupts -r--r--r-- 1 root root 0 Aug 1 18:44 iomem -r--r--r-- 1 root root 0 Aug 1 18:44 ioports dr-xr-xr-x 31 root root 0 Aug 1 18:43 irq -r--r--r-- 1 root root 0 Aug 1 18:44 kallsyms crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 kcore -r--r--r-- 1 root root 0 Aug 1 18:44 key-users crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 keys -r-------- 1 root root 0 Aug 1 18:44 kmsg -r-------- 1 root root 0 Aug 1 18:44 kpagecgroup -r-------- 1 root root 0 Aug 1 18:44 kpagecount -r-------- 1 root root 0 Aug 1 18:44 kpageflags -r--r--r-- 1 root root 0 Aug 1 18:44 loadavg -r--r--r-- 1 root root 0 Aug 1 18:44 locks -r--r--r-- 1 root root 0 Aug 1 18:44 meminfo -r--r--r-- 1 root root 0 Aug 1 18:44 misc -r--r--r-- 1 root root 0 Aug 1 18:44 modules lrwxrwxrwx 1 root root 11 Aug 1 18:44 mounts -\u0026gt; self/mounts dr-xr-xr-x 2 root root 0 Aug 1 18:44 mpt -rw-r--r-- 1 root root 0 Aug 1 18:44 mtrr lrwxrwxrwx 1 root root 8 Aug 1 18:44 net -\u0026gt; self/net -r--r--r-- 1 root root 0 Aug 1 18:44 pagetypeinfo -r--r--r-- 1 root root 0 Aug 1 18:44 partitions crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 sched_debug lrwxrwxrwx 1 root root 0 Aug 1 18:43 self -\u0026gt; 30 -rw------- 1 root root 0 Aug 1 18:44 slabinfo -r--r--r-- 1 root root 0 Aug 1 18:44 softirqs -r--r--r-- 1 root root 0 Aug 1 18:44 stat -r--r--r-- 1 root root 0 Aug 1 18:44 swaps dr-xr-xr-x 1 root root 0 Aug 1 18:43 sys --w------- 1 root root 0 Aug 1 18:43 sysrq-trigger dr-xr-xr-x 2 root root 0 Aug 1 18:44 sysvipc lrwxrwxrwx 1 root root 0 Aug 1 18:43 thread-self -\u0026gt; 30/task/30 crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 timer_list dr-xr-xr-x 4 root root 0 Aug 1 18:44 tty -r--r--r-- 1 root root 0 Aug 1 18:44 uptime -r--r--r-- 1 root root 0 Aug 1 18:44 version -r-------- 1 root root 0 Aug 1 18:44 vmallocinfo -r--r--r-- 1 root root 0 Aug 1 18:44 vmstat -r--r--r-- 1 root root 0 Aug 1 18:44 zoneinfo  在此介绍几个比较重要的部分：\n   /proc/N PID 为 N 的进程信息     /proc/N/cmdline 进程启动命令   /proc/N/cwd 链接到进程当前工作目录   /proc/N/environ 进程环境变量列表   /proc/N/exe 链接到进程的执行命令文件   /proc/N/fd 包含进程相关的所有文件描述符   /proc/N/maps 与进程相关的内存映射信息   /proc/N/mem 指代进程持有的内存，不可读   /proc/N/root 链接到进程的根目录   /proc/N/stat 进程的状态   /proc/N/statm 进程使用的内存状态   /proc/N/status 进程状态信息，比 stat/statm 更具可读性   /proc/self/ 链接到当前正在运行的进程    如果像了解更多的话，请自行 google 或者看看 Linux Filesystem Hierarchy: 1.14. /proc。\nDocker 如何利用到 /proc？ 参考  Linux Filesystem Hierarchy: 1.14. /proc 《自己动手写Docker》\n wiki: procfs\n  ","date":1564711449,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1564711449,"objectID":"9c30e1535be0f93924665488a826dd32","permalink":"https://youngwilliamz.github.io/post/linux-proc/","publishdate":"2019-08-02T02:04:09Z","relpermalink":"/post/linux-proc/","section":"post","summary":"我的 Docker 原理探索之路","tags":["linux","docker","proc"],"title":"Docker 背后： Linux 的 /proc","type":"post"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 还没好好看一遍《剑指Offer》，希望在阅读的过程中能记录一下，同时也方便以后复习。\n3. 高质量的代码 3.2 代码的规范性 代码的完整性:  功能测试：要满足基本功能、尽量突破常规思维的限制 边界测试：考虑循环、递归终止条件；字符串转整数时确保极大极小值等。 负面测试：各种可能的错误输入  3 种错误处理的方法：     优点 缺点     返回值 和系统 API 一致，0 为正常，其他为错误 不能方便使用计算结果   全局变量 可以直接得到计算结果，方便使用 很容易忘记检查   异常 逻辑清晰，明确定义错误类型 一些语言不支持，对性能有负面影响    具体用哪种需要考虑具体场景，可以和面试讨论一下采用哪种比较合适。\n","date":1564337845,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1564337845,"objectID":"7dcc94958f48e1c1dea3c9e086e2b1ac","permalink":"https://youngwilliamz.github.io/post/coding-interviews-note-1/","publishdate":"2019-07-28T18:17:25Z","relpermalink":"/post/coding-interviews-note-1/","section":"post","summary":"《剑指Offer》笔记，不定时更新～","tags":["笔记","剑指Offer"],"title":"《剑指Offer》笔记","type":"post"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 今天面试 CSIG 被问到 docker build 的原理。感觉自己答的不是面试官想要的结果。于是特此整理一下。\n以下是我的原回答：\ndocker build 就是通过 Dockerfile 编译出一个自定义的镜像（image）。具体过程是：Dockerfile 里面的一行一行的命令一层层地生成镜像。如果某一行被改了，那么如果再 build 一次的话就会从这一行开始 build 新的镜像，而之前上一行所 build 的镜像并不会改变。\n然后我就被打断了。面试官问：\n其实我问的不是 Dockerfile 内部的语句是怎么运行的。我问的是 docker build 这背后发生了什么？\n然后我就懵圈了，我又简单复述了一遍刚刚说所的，然后就果断说就了解这些。（真的不会了。。。）\n面试官一听就感觉我不太行就换了其他的问题。\n废话不多说，进入正题。\nWhat is Docker build ?  Build an image from a Dockerfile\n 参考  Docker 镜像之进阶篇   ","date":1555975214,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1555975214,"objectID":"6bcf5bc7e3a387ad938789e2254407f1","permalink":"https://youngwilliamz.github.io/post/learn-docker-behind-docker-build/","publishdate":"2019-04-22T23:20:14Z","relpermalink":"/post/learn-docker-behind-docker-build/","section":"post","summary":"我的 Docker 原理探索之路","tags":["Docker"],"title":"Docker 学习笔记之 docker build 背后","type":"post"},{"authors":["YoungWilliam"],"categories":["搞机"],"content":"  此方案已失败，但还是可以参考的，说不定你就成功了？\n 宿舍的路由器一直不太好用，今天把之前买的 K2P 重新刷了 OpenWRT 新版系统。WAN 6 可以获取到 IPv6 的公网地址，可是发现 LAN 口只能获取本地的 IPv6，用不了，连不上北邮人，每次都得切到 SUSTC-Wifi 才能连，实在非常不方便。于是就研究了几小时绕了一大圈才找到可行的解决办法。在此记录下。\nWAN 6 设置 协议：DHCPv6 客户端 请求 IPv6 地址：try（不能选 force）\nLAN 设置 最下面 DHCP 服务器 中 IPv6 设置 下：\n 路由通告服务、DHCPv6 服务、NDP 代理全部选为混合模式。这样 WAN 6 和 LAN 就都可以获得公网 IPv6。 DHCPv6 模式 选择 无状态的 + 有状态的  “上面「一般配置-物理设置」，找到「接口」，点击最右边的小三角，弹出下拉菜单。默认这里「交换机 VLAN eth0.2 (lan, wan, wan6)」是没有选上的吧？勾选上这个。为啥选这个呢？因为它有 wan6 哇～”\n保存并应用。等一段时间还没有生效的话，就重启。我是重启完立马就有了原生 IPv6。\n主要参考 OpenWrt IPv6 中继\nPS 我自己在之前的教程中修改了 /etc/config/dhcp，不知道有没有影响。 只是在config dhcp 'lan' 的最下面添加了 option master '1'。如果上诉方法对你不起作用，可以试试这个或者使用 NAT。\n","date":1552211335,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1552211335,"objectID":"45f21fe8d0a52a6369905f91000d89e5","permalink":"https://youngwilliamz.github.io/post/openwrt-ipv6-relay/","publishdate":"2019-03-10T09:48:55Z","relpermalink":"/post/openwrt-ipv6-relay/","section":"post","summary":"此方案失败了，但还是可以参考的，说不定你就成功了？","tags":["OpenWRT","IPv6"],"title":"OpenWRT 18.06 IPv6 开启 Relay，LAN 口获取 IPv6 公网地址","type":"post"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 目录 HAHAHUGOSHORTCODE-TOC0-HBHB\n背景 这门课是张哥（stormzhang）在朋友圈推荐的，买的话可以直接进入 Caoz 的星球。我主要是冲着星球去的，因为星球价值真的高啊。其实之前本来就打算进星球的，无奈刚换电脑，比较拮据，就只好等待机会。进了星球，发现一堆创业大佬，就是一个人脉圈啊，有没有作用，就看你的本事了。以上就是星球附赠的课程《成长的烦恼》的由来。因为时间限制，28 号晚上就会无法访问，就想称此机会好好读读。\n1. 读书时代 1.1. 尽早确立职场目标并准备 曹大在这里描述了一下自己的学生生涯，悔恨自己当初没有好好学好专业课，以至于错失许多机会。\n摘录：\n 对于专业技能，特别是计算机的专业技能，我建议是一精多通：你能在某个特定领域达到足够的高度，而其他相关领域达到一定的标准。原因：\n 需要跟不同领域的人沟通时，更好地理解对方，换位思考，降低沟通成本。 可以在特殊情况下自己干。 企业喜欢这种全才。   1.2. 切忌陷入自以为是的境地  为什么自以为是？信息获取的渠道很窄。=》价值观趋同，社会认知趋同。\n很多真正很有价值的真相，在读书的时候是看不见的。你从媒体看互联网，你从那些成功者的演说里看互联网，你是看不到真相的。\n如何解决？ 多跟不同人群沟通。 尽早实习，多跟不同部门沟通。\n例子1: 遇到没有听说过的的公司可以去搜一下资料，\u0008并且听听他们的宣讲。 “今天见到李开复咯，收获好大哦～收获了啥呢？朋友圈的赞。。。”\n 1.3. 基础思想和逻辑需要尽早培养 \u0008理解公式来锻炼自己的理解能力。\n世界上大部分人不\u0008具备逻辑能力。无法用最优解的思想去思考。\n\u0008学好基础，\u0008培养思想，而不是\u0008去学工具。\n2. 关于求职  经常的错误：\u0008不尊重职场。 求职前要有\u0008准备，要调研，要在简历中体现你的准备和思考。\n 要谦虚\u0008和积极。 愿意从基层做起，从小事做起。\n 职场要体面一点。 初次相遇，一切重要场合还是需要的。\n 面试问问题。要有准备。基于企业的公开信息进行提问，挖掘出深度问题。\n  3. 个人职场定位 3.1. 找到个人专长 \u0008\u0008“\u0008看上去很全能，其实不堪一击。\u0008”\n3.2. 好奇心是动力之源 “一定要知道自己最痴迷什么？”\n“我是怎么甄别信息的，其实很简单，就是好奇心。对某一个新闻，有些人有好奇心就会去挖掘这些信息，而大多数人是不关心的。”\n3.3. 要建立全局意识和整体感 “对行业、专业的要有认知，\u0008知道机会和方向在哪儿，要知道自己更上台阶\u0008需要去哪儿。”\n“所以我经常建议年轻人，读书的，没毕业的或刚毕业的多多看看行业内顶尖企业的财报，了解行业发展的规模/竞争态势。”\n“新兴\u0008领域\u0008、新兴机会也要多看看，比如百度的\u0008热榜，爱站指数，认真挖掘，对行业认知的\u0008其实会增加许多。”\n提到几位人物：余军、边江、高少星\n“多去了解企业整体架构。了解公司的核心价值和主要方向。”\n“职场秘密：\u0008快速拓展的公司，很多\u0008中层为了自己的发展，快速启动新的项目团队，每个项目看上去都很有价值很有机会，\u0008\u0008然后大家忙忙碌碌为了新的机会各种打拼。但是，其实从公司战略和格局来说，绝大多数都是试验品、甚至是垃圾。等到市场风向逆转的时候，老板开始核查成本，这些乱七八糟的玩意儿全部砍掉。\u0008你觉自己很拼，很有贡献，可在老板眼里一文不值。”\n“\u0008一定要站的高一点，站在上司的位置\u0008看问题，看机会，看方向。如果看不到，多问！”\n“把四五个人的工作量\u0008给一个人做，可能会发现只有少数的事有必要做。”\n佩服的人：李兴平，做网站特别强。在没有\u0008资源的情况下，比专业人士\u0008做的好。\n3.4. 关于个人待遇的话题 \u0008“职场定位，你要对自己的发展\u0008目标有整体的\u0008认识。”\n 发展期：20-30 关注成长，只有吃苦。\u0008只有少数人能真正踩对路，少走弯路。 成熟期：30-35 达到Top10% 提高企业职位、提高业界影响力、建立人脉。  “不需要顶尖水平，因为很多顶尖水平的人没意识到这一点。\u0008” “达到领域内 Top 10% 并不难，绝大部分\u0008人又懒又爱给自己找借口。”  变现期：35之后务必快速走入变现期。能力够了，影响力和口碑够了。\u0008这个时候就要让自己价值最大化。  索要期权，知道整个期权的比例。\u0008要有概念。\n创业要\u0008确定好退出条款。毕竟「\u0008能共患难，不一定能共享福。」\n3.5. 互相成就 写工作报告的时候将帮助过自己的人写进去，不仅可以帮助别人，对自己也没什么损失，\u0008何乐而不为呢？\n4. 谈谈创业 这个部分曹大\u0008讲了许多\u0008自己的例子。大部分内容在曹大的文章都有提及，就不一一粘贴了。\u0008\n4.1. 创业需要视野和格局 “\u0008所以创业有几个教训：1. 居安思危，眼光要长远。 2. 动作要快，行动力要强。 3. 必要的时候需要魄力，需要团队，需要资金，不能当干。单干格局太低。\u0008”\n“\u0008你写了很多代码，很酷的技术，\u0008没有人用，很少人用，你技术再牛又怎么样呢？\u0008你代码很简单，被广泛用起来，而且为别人真正带来了价值，你的工作就是很有价值。”\n创业历程：\n 上世纪末：  \u0008交换链。错失 hao123  2004：  OA系统，一个人\u0008，安装包压缩到 5m。代码量大，但用的人不多。 统计系统。代码量少，但很多人用。\u0008   4.2. 创业需要懂得价值评估 4.3. 更好的理解人性 4.4. 财务和数据 5. 总结与回复 \u00086. \u0008最后的感受 \u0008这是我自己听完曹大课的感受。\u0008曹大在这期课程里着重强调了\u0008看待事物的全局观和自己的好奇心。\u0008\n先说说\u0008全局观，\u0008我觉得全局观\u0008就是在多个角度想问题：从领导角度也好，从别的部门角度也好，总之就是\u0008多\u0008想想，多看看\u0008，\u0008搞明白市场的变化方向，理解\u0008最重要的核心，\u0008\u0008理解好利益冲突。\n\u0008再说说好奇心，曹大的信息筛选全凭好奇心。\u0008而曹大的好奇心有点\u0008跟我的不太一样，他对许多未知的事物都感到好奇，希望更多地了解，会从一则小新闻里衍生地去查很多相关资料。\n另外说一句，有实效性的课程真的能够克服懒癌，能够逼着自己去读完听完而不浪费难得的机会。想想躺在书架上的那么多书还没怎么翻过，还有「\u0008极客时间」里的\u0008\u0008十几个课程还只看了一点点，\u0008而我却没有一丝愧疚。\u0008\u0008\u0008\u0008可能我还不够优秀吧。\n","date":1546033735,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546033735,"objectID":"8175b713802bf72e63d932821f0d7eef","permalink":"https://youngwilliamz.github.io/post/caoz-class-node/","publishdate":"2018-12-28T21:48:55Z","relpermalink":"/post/caoz-class-node/","section":"post","summary":"匆匆读一下 CaoZ 大佬在「易灵微课」开通的《成长的烦恼》笔记","tags":["Caoz","思维方式"],"title":"Caoz《成长的烦恼》笔记","type":"post"},{"authors":["YoungWilliam"],"categories":["搞事"],"content":"","date":1539444736,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1539444736,"objectID":"766d0b98d87e809ba1e65b547989993f","permalink":"https://youngwilliamz.github.io/project/sustctong/","publishdate":"2018-10-13T23:32:16+08:00","relpermalink":"/project/sustctong/","section":"project","summary":"为南科大（SUSTech）的师生提供方便的信息查询，包括校园巴士时间、课程表信息等。","tags":["微信小程序"],"title":"南科通 微信小程序","type":"project"},{"authors":["YoungWilliam"],"categories":["工欲善其事"],"content":" 先上最终效果图：\n\u0008目录  \u0008目录 1. 相关工具介绍 2. 配置总览 3. 安装步骤  3.1. 安装 iTerm2 3.2. 安装XCode’s Command line tools 3.3. 检查 zsh 是否已安装 3.4. 安装 Oh-My-Zsh 3.5. 安装 Powerline fonts 3.6. 安装配置主题 3.7. 修改命令提示符 3.8. 配置 zsh 命令语法高亮  4. 备用下载链接 5. 参考及感谢  1. 相关工具介绍  iTerm2： Terminal 终端的替代品，拥有更多强大的功能，想了解更多请戳 iTerm2 官网； XCode’s Command line tools: 开发环境集成，包含 git、gcc 等重要工具； zsh：Linux 的一种 shell 外壳，强大的虚拟终端，和 bash 属于同类产品，OS X 已自带； Oh-My-Zsh: 用来管理 zsh 的配置，同时还有很多社区贡献的主题配置以及好用的插件可供使用，了解更多请戳 Oh-My-Zsh 官网；  2. 配置总览  iTerm2 Oh-My-Zsh agnoster 主题 zsh 命令语法高亮  3. 安装步骤 3.1. 安装 iTerm2 进入官网下载页面，点击 Stable Releases 下面的 Download 即可下载，解压后拖到应用程序中。这是简单的一小步，但是却是优化 Terminal 的一大步！\nPS: 网络环境不太好的同学不要担心，我已经把安装包传到百度云了，请到文章最后寻找链接下载。\n3.2. 安装XCode’s Command line tools XCode 13 个 G ,这里我们只需要 XCode’s Command line tools 来支撑 Git 的使用，所以我们不用费时费力装 XCode 来浪费那13个G。 (从 Yosemite（10.10+）开始，Command Line Tools 可以单独安装。)\n安装方法: 打开终端，输入\nxcode-select –install  点 install ，同意，即可。\n3.3. 检查 zsh 是否已安装 在命令行输入：\nzsh --version  如果显示\nzsh 5.3 (x86_64-apple-darwin17.0)  即zsh的当前版本号，就说明装好了，一般 OS X 自带有的。\n如果没装则需要输入：\nbrew install zsh zsh-completions  这是用Homebrew装，需要 OS X 上有Homebrew，它的网站：https://brew.sh/\n3.4. 安装 Oh-My-Zsh 可以通过 curl 或者 wget 来安装\n curl\nsh -c \u0026quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;  wget\nsh -c \u0026quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;   网络好的话几秒就装好了。\n一般安装程序会自动把默认的 shell 切换为 zsh, 什么！你不懂 shell 是什么？我也不懂，你去问问度娘？或者直接右上角？其实不懂也正常，也不影响你拥有自己美美的终端。\n如果想修改默认 shell 为原来的 bash：\nchsh -s /bin/bash  重启 iTerm2 就好了。\n3.5. 安装 Powerline fonts 华丽丽的主题需要 Powerline 字符集的支持。 通过 git 安装, 直接执行以下命令行：\ngit clone https://github.com/powerline/fonts.git --depth=1; cd fonts; ./install.sh; cd ..; rm -rf fonts  然后到 iterm2 配置，设置字体 1. 打开 Preferences，选择 Profiles 2. 选择 Text，点击 Change Font 3. 选择固定宽度，选择自己喜欢的字体。注意： iTerm2 可以实时看到效果，结尾不是 for Powerline 的会乱码。 4. 接着修改字体颜色，选择另一项 Colors, 点击 Color Presets, 选择Solarized Dark 3.6. 安装配置主题 装好之后就可以换到 agnoster 主题，Oh My Zsh 一般自带有这个主题。\n可以看看其它的默认主题：\nls ~/.oh-my-zsh/themes  需要修改主题只需：\nvim ~/.zshrc  然后把里面 ZSH_THEME 的值改为 ZSH_THEME=\u0026ldquo;agnoster\u0026rdquo;，保存退出。\n修改和保存的过程为： 1. 按下 i 开始编辑 2. 通过方向键控制光标的位置 3. 定位到 ZSH_THEME 4. 改为 ZSH_THEME=\u0026quot;agnoster\u0026quot; 5. 按下 ESC, 输入 :wq, 回车 6. 搞定！\n（点击这里还有各种主题预览，任君翻牌~）\n3.7. 修改命令提示符 默认的命令提示符为 user@userdemackbookPro，这样的提示符配合 powerlevel9k 主题太过冗长，因此我选择将该冗长的提示符去掉，在 ~/.zshrc 配置文件后面追加如下内容：\n# 注意：DEFAULT_USER 的值必须要是系统用户名才能生效 DEFAULT_USER=\u0026quot;user\u0026quot;  编辑方法同上。\n3.8. 配置 zsh 命令语法高亮 zsh-syntax-highlighting 插件可以使你终端输入的命令有语法高亮效果，安装方法如下（oh-my-zsh 插件管理的方式安装）： 1. 复制文件到插件目录 bash git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting  2. 修改 ~/.zshrc 添加插件 bash # 注意：zsh-syntax-highlighting 必须放在最后面（官方推荐） plugins=( [plugins...] zsh-syntax-highlighting)   应用修改\nsource ~/.zshrc   大功告成~有问题欢迎留言讨论~\n4. 备用下载链接 iTerm2 ( 3.2.0 )： 链接: https://pan.baidu.com/s/1Wm7NjtGfA81LpGFYAaEAPQ 密码: ksgv\n5. 参考及感谢  我的 Mac 终端配置（Mac OSX + iTerm2 + Zsh + Oh-My-Zsh） iTerm2 + OhMyZsh + agnoster + Powerline + solarized = 漂亮的Mac终端  ","date":1533995520,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1533995520,"objectID":"42f6102424f12658cdb39d212c149451","permalink":"https://youngwilliamz.github.io/post/optimize-the-terminal-in-mac-os-x/","publishdate":"2018-08-11T13:52:00Z","relpermalink":"/post/optimize-the-terminal-in-mac-os-x/","section":"post","summary":"Mac 大法好","tags":["Max OS X"],"title":"Mac OS X 下优化 Terminal，一篇就够了！","type":"post"},{"authors":["YoungWilliam"],"categories":["Markdown"],"content":" 目录 HAHAHUGOSHORTCODE-TOC0-HBHB\n总结一下，Hexo 下 Markdown 的写法和一些奇技淫巧。\n说明：Hexo 主题为 Next\n标题及分类 格式：(使用 HexoEditor 新建Post 可以自动生成以下内容)\n--- title: Hexo 使用 Markdown 编辑技巧大全 tags: - Hexo - Markdown categories: - Markdown date: 2018-07-10 15:29:00 ---  阅读更多 Hexo 主页每篇文章可以显示 Read More 按钮，只显示以下这一行以上的文章内容。 格式：\n\u0026lt;!-- more --\u0026gt;  Markdown 语法 Markdown 语法主要分为如下几大部分： * 标题 * 段落 * 区块引用 * 代码区块 * 强调 * 列表 * 分割线 * 链接 * 图片 * 反斜杠 \\ * 符号\u0026rsquo;`\u0026rsquo;\n标题 两种形式：\n1）使用=和-标记一级和二级标题。 \u0026gt; 一级标题\n\u0026gt; =========\n\u0026gt; 二级标题\n\u0026gt; ---------\n效果： \u0026gt; 一级标题\n\u0026gt; =========\n\u0026gt; 二级标题 \u0026gt; \u0026mdash;\u0026mdash;\u0026mdash;\n2）使用#，可表示1-6级标题。 \u0026gt; # 一级标题\n\u0026gt; ## 二级标题\n\u0026gt; ### 三级标题\n\u0026gt; #### 四级标题\n\u0026gt; ##### 五级标题\n\u0026gt; ###### 六级标题\n效果： \u0026gt; # 一级标题\n\u0026gt; ## 二级标题\n\u0026gt; ### 三级标题\n\u0026gt; #### 四级标题\n\u0026gt; ##### 五级标题\n\u0026gt; ###### 六级标题\n段落 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。\n区块引用 在段落的每行或者只在第一行使用符号\u0026gt;,还可使用多个嵌套引用，如： \u0026gt; \u0026gt; 区块引用\n\u0026gt; \u0026gt;\u0026gt; 嵌套引用\n效果： \u0026gt; 区块引用\n\u0026gt;\u0026gt; 嵌套引用\n代码区块 代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如\n普通段落：\nvoid main()\n{\nprintf(\u0026ldquo;Hello, Markdown.\u0026rdquo;);\n}\n代码区块： 如： \u0026gt; ``` C \u0026gt; void main() \u0026gt; { \u0026gt; printf(\u0026ldquo;Hello, Markdown.\u0026rdquo;); \u0026gt; } \u0026gt; ```\n效果：\nvoid main() { printf(\u0026quot;Hello, Markdown.\u0026quot;); }  注意: ``` 之后可以添加语言种类如 C、Java、Bash, 需要和普通段落之间存在空行。\n强调 在强调内容两侧分别加上*或者_，如： \u0026gt; *斜体*，_斜体_\n\u0026gt; **粗体**，__粗体__\n效果： \u0026gt; *斜体*，斜体\n\u0026gt; 粗体，粗体\n列表 使用·、+、或-标记无序列表，如： \u0026gt; -（+*） 第一项 \u0026gt; -（+*） 第二项 \u0026gt; - （+*）第三项\n注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n效果： \u0026gt; + 第一项 \u0026gt; + 第二项 \u0026gt; + 第三项\n有序列表的标记方式是将上述的符号换成数字,并辅以.，如： \u0026gt; 1 . 第一项\n\u0026gt; 2 . 第二项\n\u0026gt; 3 . 第三项\n效果： \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; 3. 第三项\n分割线 分割线最常使用就是三个或以上*，还可以使用-和_。\n链接 链接可以由两种形式生成：行内式和参考式。\n行内式： \u0026gt; [YoungWilliam的博客](https://youngwilliamz.github.io/)\n效果： \u0026gt; YoungWilliam的博客\n参考式： \u0026gt; [YoungWilliam的博客1][1]\n\u0026gt; [YoungWilliam的博客2][2]\n\u0026gt; [1]:https://youngwilliamz.github.io/ \u0026gt; [2]:https://youngwilliamz.github.io/\n效果： \u0026gt; YoungWilliam的博客1\n\u0026gt; YoungWilliam的博客2\n\u0026gt; YoungWilliam的博客3\n注意：上述的[1]:https://youngwilliamz.github.io/不出现在区块中。\n图片 添加图片的形式和链接相似，只需在链接的基础上前方加一个！。\n反斜杠\\ 相当于反转义作用。使符号成为普通符号。\n符号 ` 起到标记作用。如： \u0026gt;`ctrl+a`\n效果： \u0026gt;ctrl+a\n注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。 虽然有人想出面搞一个所谓的标准化的Markdown，没想到还惹怒了健在的创始人John Gruber。\n以上基本是所有traditonal markdown的语法。\n其它 列表的使用(非traditonal markdown)：\n用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 格式：\n|代码库 |链接 | |:------------------------------------:|------------------------------------| |MarkDown |[https://github.com/younghz/Markdown](https://github.com/younghz/Markdown \u0026quot;Markdown\u0026quot;)| |MarkDownCopy |[https://github.com/younghz/Markdown](https://github.com/younghz/Markdown \u0026quot;Markdown\u0026quot;)|  效果:\n   代码库 链接     MarkDown https://github.com/younghz/Markdown   MarkDownCopy https://github.com/younghz/Markdown    关于其它扩展语法可参见具体工具的使用说明。\n参考文章 Markdown 基本语法\n","date":1531236540,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1531236540,"objectID":"4c84adadbff99c9c09c6fc3816fcd9df","permalink":"https://youngwilliamz.github.io/post/hexo-markdown/","publishdate":"2018-07-10T15:29:00Z","relpermalink":"/post/hexo-markdown/","section":"post","summary":"可能还不全，哈哈哈，看官请随意。","tags":["Hexo","Markdown"],"title":"Hexo 使用 Markdown 编辑技巧大全","type":"post"},{"authors":["YoungWilliam"],"categories":["Hexo"],"content":"直接上代码，src对应的是图片 url\n\u0026lt;img src=\u0026quot;https://i.loli.net/2018/06/24/5b2edf5139f61.png\u0026quot; width=\u0026quot;50%\u0026quot; height=\u0026quot;50%\u0026quot;\u0026gt;  效果图如下：（使用的是 SM.MS图床）\n","date":1529827320,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1529827320,"objectID":"b4d76c3e309e35b1b743a8b907e16b6d","permalink":"https://youngwilliamz.github.io/post/hexo-image-edite-method/","publishdate":"2018-06-24T08:02:00Z","relpermalink":"/post/hexo-image-edite-method/","section":"post","summary":"Hexo 小技巧","tags":["Hexo","Markdown"],"title":"Hexo 下特有的编辑图片方式，直接使用 img 标志","type":"post"},{"authors":["YoungWilliam"],"categories":["Hexo"],"content":"  本文用于记录以及简单的安装\n 目录 HAHAHUGOSHORTCODE-TOC0-HBHB\n简单介绍 HexoEditor 是 Github 上一款开源的 Markdown 编辑器。\n引用原作者说的话： \u0026gt; 这是一款为 Hexo 做了优化的 Markdown 编辑器。 使用 Electron 做框架 修改自 Moeditor, 我只是为了让他更好的去为 Hexo 下的博客更好的去书写内容。\n同时它还包括很多功能，其中我觉得最有用的就是： \u0026gt; 预览内容与 Hexo 生成页面内容高度相似\n更多详情介绍请点击这里。\n安装过程 整个过程参照官方文档。\n1.准备工作 安装 git  Download Page for Mac OS X Download Page for Windows Download Page for Linux/Unix  安装 nodejs  Download Page (English) 下载地址 (中文)  2.下载配置 Hexo 3.设置 npm 缓存路径 Windows 下 npm config set prefix \u0026quot;C:/Program Files/nodejs/npm_global\u0026quot; npm config set cache \u0026quot;C:/Program Files/nodejs/npm_cache\u0026quot;  Linux\\Mac 下 npm config set prefix \u0026quot;~/nodejs/npm_global\u0026quot; npm config set cache \u0026quot;~/nodejs/npm_cache\u0026quot;  注意：这里的路径是你安装 nodejs 的子目录下对应的路径\n4.设置下载来源（镜像），加速下载 来自原作者好心提醒： 在中国，你应该设置淘宝镜像来加速下载。(PS: 这个我没试过，我是直接通过代理的)\nnpm config set registry \u0026quot;https://registry.npm.taobao.org/\u0026quot; npm config set electron_mirror \u0026quot;https://npm.taobao.org/mirrors/electron/\u0026quot;  5.下载 GitHub 上最新的版本并安装 git clone https://github.com/zhuzhuyule/HexoEditor.git cd HexoEditor npm install  6.启动 npm start  然后，当当当，启动啦~\n设置快捷方式 在 HexoEditor 子目录下，新建 start.sh ，编辑（右键-\u0026gt;打开方式-\u0026gt;NotePad++），输入（其实就是启动）\nnpm start  保存，退出，双击一下 start.sh ，看看效果如何~ 顺利的话，gitbash 会弹出来，然后 HexoEditor就会弹出来了~\n本教程到此就结束了，希望大家玩的开心~\n","date":1529820480,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1529820480,"objectID":"ca9ef4d95e27827c9683fd92051e9844","permalink":"https://youngwilliamz.github.io/post/hexoeditor/","publishdate":"2018-06-24T06:08:00Z","relpermalink":"/post/hexoeditor/","section":"post","summary":"不了解一下？","tags":["编辑器","Hexo","Markdown"],"title":"HexoEditor, 一个写 Hexo 非常好用的 Markdown 编辑器","type":"post"}]