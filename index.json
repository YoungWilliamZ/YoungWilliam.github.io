[{"authors":["admin"],"categories":null,"content":" 初出茅庐开发仔 拖延症晚期患者 熬夜不累早起难 云撸猫受益者 B 站白嫖大师  ","date":1570463813,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":1570463813,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://youngwilliamz.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":" 初出茅庐开发仔 拖延症晚期患者 熬夜不累早起难 云撸猫受益者 B 站白嫖大师  ","tags":null,"title":"YoungWilliam","type":"authors"},{"authors":null,"categories":null,"content":"自从 2018 年的那个暑假第一次接触 Docker 以来，几乎每个项目几乎都用到了 Docker。\n虽然我对 Docker 如此感兴趣，但一直没有深入去了解 Docker 底层的实现，因此我希望能够通过这本笔记，记录一下我学习 Docker 的过程以及最近打算手撸一个简易版本 Docker。\n","date":1565711906,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1565711906,"objectID":"5f5eb8b7625d291e649e30c17bc4ba0a","permalink":"https://youngwilliamz.github.io/note/docker/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/docker/","section":"note","summary":"万事开头难，Docker也不难。","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":" 关于写本书的初衷 算法是程序员最核心的能力！\n主要是自己容易犯懒，喜欢去折腾一些有的没得，比如这个博客。开始这本书的时候，也就是现在，我已经大三结束了，暑假都快过完了。秋招都已经开始了。但我 LeetCode 只刷了十几道，感觉完全不够用，因此希望借此能够激励或者督促自己坚持下去，而不是三天晒网，两天打鱼。\n此书的目录 关于此书的目录是根据 LeetCode 官方的 Top Interview Questions 来的。当然中文版（算法面试题汇总）也有，不过中文版的题目还不够健全。\n我的刷题方式 本着快速刷题的宗旨，我不会在一题上面纠结很久，顶多 5 分钟就可以看答案了。因此，我会优先做有官方答案的题目，保证刷题的效率。\n面试小总结 今天（2019年9月1号）下午面了字节跳动，发现考的算法题基本都是《剑指offer》中的题。但我偏偏没有好好练熟里面的题，只是看了一遍了解大概思想之后，并没有动手实践。因此今天面试的时候虽然思路有了，但手撕代码特别慢，二面被挂了。希望大家引以为戒，特别是找工作的同学们，优先刷《剑指offer》，最好自己手敲一遍。\n","date":1565711906,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1565711906,"objectID":"1bf6a8ef4e1da6d00cb3969f598292c8","permalink":"https://youngwilliamz.github.io/note/leetcode/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/","section":"note","summary":"个人刷题笔记，欢迎指正，交流。","tags":null,"title":"Overview","type":"docs"},{"authors":[],"categories":[],"content":" Offer 汇总 实习：\n 360 网络安全研究院 Web平台开发实习生 小赢科技 架构部 基础组件组 后端开发实习生  最终选择：小赢科技\n秋招：\n 小米 后端开发（北京） 富途牛牛 后端开发（深圳） 欢聚时代 后端开发（广州） 华为 软件开发（深圳） 网易游戏 游戏应用与平台发展事业部 服务端平台开发（广州） 酷家乐 容器开发（杭州） 360搜索 后端开发（北京） 腾讯 TEG 基础架构部 运营开发（深圳）  最终选择：腾讯\n##暑期实习\n先介绍下找实习前我的基本情况。\n大一的时候，我已经知道系里要求每位同学都要进行实习，最好的时间点就在大三的暑假。于是在大一暑假我就开始试着找实习，因为当时只学了Java，所以只能在一位亲戚的帮助下去了顺德的一家小公司边学边做 Android APP 的开发。\n大二暑假，我想靠自己找实习。但是当时没有那么强的驱动力和能力（计算机网络、操作系统都还没学呢），最后在学校跟两个同学一起做了一个查询校巴时间的微信小程序。虽然当时有500人的用户，但因为竞争不过校内同类型的小程序，最后不再维护。\n在大三下的一开始，我就明确要开始找实习了。根据前两个暑假的摸索，我确定了自己不想做Android或者前端的开发工作，所以我选了后端开发作为我的方向。我的目标是腾讯，如果要进腾讯，那么C++是必须掌握的，所以我开始学习C++。从现在看来，对于C++的学习，我开始的太晚了，在找实习的关键时期才开始学。这也为我接下来找实习埋下了隐患。\n找实习第零步：准备简历 对于简历，我是从大一就有开始准备的，大二的时候就已经找学校就业中心的老师指导完善，而且学长、导师也会帮忙过一下简历。\n对于技术岗位的应聘，简历上只要写上基本的个人信息以及专业技能与重点项目就足够了。没有个人项目的同学可以直接写创新实验的项目以及课堂Pro，重点是要把其中的技术点表述清楚，让面试官一眼了然，甚至能够“诱导”面试官进行考察，准备的时候也好针对的进行准备。至于学校社团、英语证书什么的，其实面试官不是很在意。最后，写完简历自己多看看几遍，同时可以问问同学、老师的建议，甚至可以互相进行模拟面试。\n找实习第一步：投简历 不知那时哪来的自信，以为进入腾讯实习是很简单的事，毕竟每年有3000个实习岗位。于是，我在二月中旬时通过学长的内推只投递了腾讯与阿里的实习岗位，然后就开始正常上课并抱着《C++ Primer》重点学习C++。\n4月初时后悔莫及，因为这两家公司都没有面试通过，而想再投递其他公司时已经太晚了。而且不知道是学校知名度太低，还是我的水平有限，有些公司连暑期实习的笔试都不给，比如美团、虎牙。在4月底时，我还是0 offer，牛客网上的实习板块都不见了，但我没放弃，我一直在寻找机会，甚至下载了BOSS直聘。\n对于找实习的同学，请记住：金3银4，就是三四月份是各大公司招聘暑期实习的主要时间。\n找实习第二步：准备 在一开始时，我其实并没有注重针对面试做准备，因为自认为专业课学的比较扎实，所以一切按部就班的学习。但是在头两次面试碰壁之后，我心底开始慌了，原来自己对于基础知识的掌握的都太浅了。在同学的建议下，我开始疯狂刷面经（网上其他人的面试经验），在看了十几篇面经之后，效果提升显著，我已经掌握了面试的常规问题，但这只是一些基本的计算机基础知识。这时我已经有了能够通过腾讯一面，并能跟面试官谈笑风生的能力。然而，对于算法代码的实际操练还是太少，这让我在秋招时也吃了大亏。\n找实习第三步：面试 我得到面试的机会说多不多说少不少。在学长的帮助下，腾讯我就面了3次之多（一次是微信部门直推、一次是提前批，一次是正式批），结果前两次一面就挂了，最后一次是二面挂了，挂的原因分别是算法题答不上来、常使用的方法名说不上来、简历上重点项目所使用工具不清楚背后原理。而后，是阿里区块链的部门直推，算法题答不上来。\n在遭遇两次坎坷之后，我慌了，开始疯狂投简历。随后我又拿到了几次面试机会。\n一次是在BOSS直聘上，在数十天的寻找之后，只有荔枝微课（获得A轮融资的知识分享平台）给予了我面试机会。面试是现场面试，一个下午就直接完成了笔试、技术面试、技术总监（架构师）面试、HR面。最后等了一星期通知，说是因为时间原因（他们要求5月份就开始实习，而我们学校6月才放假），无法给我发offer。HR还加了我微信，说“希望以后能有机会继续合作”。\n还有一次机会是当时与我的导师王琦老师沟通时得知的。360网络安全研究院的一个部门刚好要搬到学校对面的智园，急招实习生，而且很可能留用。面试官那个周五还要来我们学校开讲座，导师建议我把握机会。很幸运，经历了三轮面试，我顺利拿到了口头offer。\n幸运的事总是同时发生，又一个offer从天而降。当时我的创新实验项目是王琦导师与小赢科技一起合作的，而我们组每周都会去小赢科技那边与那边的导师开一次会。在得知我还没拿到offer之后，小赢科技的导师直接邀请我来小赢实习，而且不需要技术面试。\n最终，我拿到了两个offer。\n总结一下经验，每次面试基本都是10分钟至40分钟，越长代表通过的概率越大。面试失败了不要怕，最重要的事能够发现自己的不足，重新出发，相信自己最终一定能够拿到offer的。\n找实习第四步：对比 Offer 对比offer我花了足足三天。在咨询了导师以及其他同学的建议之后，我对比了实习的工作内容、所使用的技术栈、以及最重要的是为秋招做铺垫，最后我选择了小赢科技。虽然360名气比较大，可以为秋招加不少分，但技术栈是Python Web端，而我不喜欢Python，以后也不想做相关的工作。如果有的选，我会尽力不选Python相关的工作，因为我就是讨厌Python的全局解释器锁。\n实习的收获 实习的过程中，我学习了Golang和许多工业上应用实践，也确定了自己以后想深入后端想法，同时我还发现了云原生等比较热门的技术。在秋招的过程中，实习的经历让我能够在许多关键时候让面试官眼前一亮。\n秋招之路 在7月底，秋招就渐渐开始了。声势最大的是阿里的提前批，将整个牛课网的论坛都挤满了。\n简历投递 这次我不再敢只投腾讯、阿里。相反，我一开始疯狂投递其他的公司，而将腾讯阿里留在了8月中旬才投递，因为我怕一投递就被拉去面试，而我当时还在实习没有时间好好准备面试。同时我遵从了网友的建议，建了一张Excel表来记录我投递的公司、目前所在流程、流程终止的原因、是否拿到offer等情况。而且这次我不再只投递C++的岗位，而是服务端优先，其他感兴趣的也一起投。投递的城市也没有局限于广东。投递的方式也不在局限于牛课网，而是各个渠道都去收集信息，能够内推的争取内推，可谓是做好了打战的准备。\n有点遗憾的是，阿里巴巴的岗位投递太晚，所以没有拿到面试机会，希望同学们能够放下顾虑，先投了简历再慢慢准备。不要因为自己觉得准备不足而错过机会。\n以下是我建立的表格的一部分，一共57家公司，包括投递的公司名、投递时间以及岗位，有个别公司可能没有记录下来。\n   公司 投递时间 职位     网易有道 2019.7.31 Java后台   网易游戏雷云 2019.7.31 C++后台   百度 2019.7.31 C++研发   大疆创新 2019.7.30    酷狗 2019.9.6 C++后端开发培训生   Intel 2019.7.25 Linux Network Platform Software Development Engineer   小红书 2019.7.26 后端开发   4399 2019.8.20    360提前批 2019.8.8 golang   VIPKID     快手 CDN开发工程师    腾讯 2019.8.12    ThoughtWorks 2019.8.3 软件工程师   OPPO 2019.8.3 C++/JAVA   bilibili 2019.8.7 游戏后台   美团 2019.8.4    shopee 2019.8.20 后台开发   有赞 2019.8.20 中间件   贝壳 2019-07-17 C++ 研发   亚马逊     微软     小米 2019.8.8 Java软件开发   追一科技     深信服 2019.9.8    地平线 2019.8.24    顺风科技 2019.8.20 Java   招银网络     猫眼娱乐 2019.9.8    去哪儿 2019.8.14 后端   网宿科技 2019.8.14 Golang   富途牛牛 2019.9.5 C++   滴滴     快看漫画     字节跳动 2019.8.14 后端深圳   DELL     华为 2019.8.17    作业帮 2019.8.20    平安科技 2019.8.17 软件工程师-后端   虎牙 2019.8.22 中间件   酷家乐 2019.8.20 容器开发工程师   京东 2019.8.20 golang   依图科技 2019.8.22 软件开发   微众 2019.8.22 后台开发(C++开发方向)   网易 游戏 2019.8.25 服务端开发工程师-虚拟化/加速器   阅文 2019.9.5 C++   旷视     三七互娱     VIVO     源辅导 2019.9.8    七牛云 2019.9.14    云从科技 2019.9.8 golang，重庆   搜狗 2019.9.5 APP搜索-后端   中兴 2019.9.5 软件   陌陌 2019.9.6 C++开发工程师   远景 2019.9.8 C++开发工程师   度小满 2019.9.8    IBM 2019.9.29     面试准备 在不断的投递之后，我拿到了20多家公司的笔试机会，并最终拿到十几家公司的面试机会。在每次面试前，我都会将自己整理好的基础知识过一遍，同时将《剑指offer》中的算法也快速过一遍，做好最全面的准备。同时，针对面试的公司，进行最大程度的信息收集，包括业务、发展规模、创世人事迹等。\n在为面试做最好的准备之时，也不忘为自己打预防针，告诉自己面试是”玄学“，不只靠自己，还得靠天时地利人和。能拿到offer是最好的，拿不到的话也要积极复盘，查漏补缺。\n面试 在这样的心态下，每次面试我都不在像实习面试时那么紧张不安了，脑子也清晰了许多。秋招中，如果能够现场面试，面试官一定会现场面试，退而求其次是视频面试，最后才是电话面试。在绝大部份的面试中，都需要写代码，或是手写，或是直接在屏幕敲，并且写完会直接跑。因为我代码能力没有专门训练，所以我更倾向于手写代码，不仅可以通过语言的表述让面试官理解，而且也可以避免因为代码无法测试通过的尴尬。\n秋招的收获、复盘 虽然有了找实习的经验铺垫，我的秋招还是做的不够好。\n 信心不足，不敢投递国际大厂。  除了先前说的阿里巴巴投递晚了，像微软和Google这种国际大厂其实也有学长能够内推。但自己信心不足，没有去尝试，白白失去了机会。\n 代码能力没有好好锻炼，代码写一半容易卡壳。  找实习时已经发现了这个问题，想着秋招前好好刷题，补补这一块。但是因为没有规划好，没有利用好暑假的实习期间好好刷题。好几个offer就是因为代码没写好，或者思路不清晰而飞走了，比如微信、字节跳动、百度。\n 自我管理能力圈缺。  在找实习时，我已经发现：我的基础知识不够扎实，需要重新啃教材。我的项目经验不够丰富，缺少更加深入的东西。虽然我发现了这些问题，但是，直到秋招结束，自己都没有足够的动力去填补。\n 如果没有面试经验，就从小公司开始面。  一方面是小公司的面试更多是线下的，比较容易沟通。一方面是小公司的面试比较简单，可以更早的拿到offer。不仅能够积累经验，也能让自己面试、谈薪的时候更加有底气。\n 规划的太晚。  不仅是找实习没有准备好，秋招我也觉得自己没有准备完善。如果能够提前半年甚至更早就开始准备，那么找工作也就没有这么折腾了。所以关键是要早，早点确定好目标，早点准备，早点完成。\n","date":1586853928,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1586853928,"objectID":"f363748530206a8299f3b46f23d686e4","permalink":"https://youngwilliamz.github.io/post/my-journey-of-finding-jobs-2020/","publishdate":"2020-04-14T16:45:28+08:00","relpermalink":"/post/my-journey-of-finding-jobs-2020/","section":"post","summary":"南科大2020届CS毕业生找工作那点事儿","tags":[],"title":"2019年的暑期实习与秋招之路","type":"post"},{"authors":["YoungWilliam"],"categories":["学习"],"content":"最近在B站上看CSAPP的视频课，是CMU的公开课。最大的感触是国外大学对作弊抓的非常严格，平时作业连上网搜索都算作弊，更不要说看别人屏幕、让别人告诉你怎么写。一经被抓到直接不及格，并且成绩单上有永久记录。\n反观我们学校，或者说内地的绝大多数大学，只有在考试时作弊才会被严惩，而平时作业几乎不管，就算被发现抄作业也只是口头警告。\n对此我只能感叹中国教育不知道需要多少年才能追上美国。\n在我将以上感想发到「星球」上，想要了解更多国内外关于学术造假的情况。得到一下回复：\n球友「Ahus」说：\n 在瑞典读过半年书，平时作业查重力度确实比国内要高出不少，在网络上借鉴没问题但照抄的被查到后果很严重。最初会被校方约谈，之后再犯可能会被劝退或者转学\n 球友「Carl Li」说：\n 暑假刚刚亲身体验 CSAPP（CMU 这门课叫做 15-213/513），其实 15-213 这门课对于作弊的界定真的太严了，超过我之前在加州大学圣地亚哥分校上过的本科课。\n15-213 第一课一个小时二十分钟有大半的时间在讨论学术道德的问题，针对很多刚刚入学的同学，首先是对于 CMU 学术标准的一个基本介绍（CMU 容忍两次学术不端行为，第一次这门课直接挂掉，第二次开除），以及对于这门课而言哪些行为会被认定为学术不端，包括在任何搜索引擎中直接搜索课名和课号都不可以，都会直接算作弊。虽然美国大学都把学术道德问题看得非常重要，如此严厉的我还是第一次见到。\n除此之外，15-213 也不允许和任何人讨论代码，但是可以讨论顶层设计（high-level design），例如你在写 malloc 的时候可以讨论 checkheap 函数具体包含什么内容、写 proxy 的时候可以和别人讨论任何顶层设计，但是代码讨论是绝对禁止的。\n另外 15-213 不是公开课，教授亲口说过的。其实只是 CMU 一直没处理中文互联网上传的这些视频内容……能学习到的球友也建议且看且珍惜\n 球友「荼蘼」说：\n 大学是种外合办的学校，前几年去澳洲念研究生基本不要什么成绩，后来听说有个学长在澳洲念研究生作弊被劝退了，导致我们这些晚辈要去澳洲的要求分数提高了10多分\n 对此，不知道各位看官老爷有没有想法想要分享的呢？欢迎评论。\nPS. 如果有球友不想让自己的想法在此出现，请及时与我联系删除。\n","date":1570463813,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1570463813,"objectID":"a33d31cee0054ce724c67ccd5f86e93c","permalink":"https://youngwilliamz.github.io/post/csapp-note-4/","publishdate":"2019-10-07T23:56:53+08:00","relpermalink":"/post/csapp-note-4/","section":"post","summary":"国外大学对于学术造假真的严","tags":["CSAPP"],"title":"CSAPP 笔记 听课有感","type":"post"},{"authors":["YoungWilliam"],"categories":["搞机"],"content":" 起因 最近折腾群晖，发现 Jellyfin 这个玩具，可以解决用网页看视频的需求。\n折腾的途中发现有硬件加速的功能，然后发现确实有些编码格式的视频播放的时候CPU占用很高。\n看了一些评测之后发现硬件加速可以很大程度上提升视频解码的能力，同时CPU占用不会很高。\n然后发现我的 U，J1900 在 Intel 官网的介绍 中是支持 Quick Sync Video。\n于是开始了新一轮的折腾之路。\n过程 查阅一些资料之后发现，起硬件加速作用的主要是 /dev/dri。\n在映射 /dev/dri 到 docker 之后，选择 Jellyfin 硬件加速的 Intel Quick Sync Video 选项发现CPU的占用率几乎没有改变。这是怎么回事？\n正百思不得其解时，突然在论坛中发现 Intel Quick Sync Video 选项只对 Windows 的版本有用。 Linux 都是统一用 VA API 这个选项。\n结果 在使用硬件加速之后，确实效果有提升，而且CPU占用是肉眼可见的\u001c降低了，由原来的 99% 降低到 50%。播放也不卡顿了。\n参考  Enabling Quick Sync Video on Handbrake for Docker on Synology https://www.reddit.com/r/jellyfin/comments/bgbkye/trancoding_in_docker_using_qnap_nas_with_intel/ https://ark.intel.com/content/www/us/en/ark/products/78867/intel-celeron-processor-j1900-2m-cache-up-to-2-42-ghz.html)  ","date":1569871011,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569871011,"objectID":"197435b2388854cad7174de0dfe49474","permalink":"https://youngwilliamz.github.io/post/enable-quick-sync-video-for-jellyfin-on-docker-of-synology/","publishdate":"2019-10-01T03:16:51+08:00","relpermalink":"/post/enable-quick-sync-video-for-jellyfin-on-docker-of-synology/","section":"post","summary":"把踩的坑总结一下，记录下来","tags":["群晖","docker","Jellyfin","硬件加速"],"title":"群晖系统中为 Jellyfin 开启硬件加速(Quick Sync Video)","type":"post"},{"authors":null,"categories":null,"content":" 前言 最近需要把之前做的 openCredit 项目重新部署一下，发现好久不用的 aliyun 云服务器的磁盘已经快满了。\n使用 df -h 命令一看：\n➜ ~ df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 37G 820M 98% / devtmpfs 910M 0 910M 0% /dev tmpfs 920M 0 920M 0% /dev/shm tmpfs 920M 716K 919M 1% /run tmpfs 920M 0 920M 0% /sys/fs/cgroup overlay 40G 37G 820M 98% /var/lib/docker/overlay2/55aedbcf20a0380e7e03075a7a97a59869ba9c61848a28c3eb8dacc6df00e01d/merged overlay 40G 37G 820M 98% /var/lib/docker/overlay2/7bc1cd18dea024f05c9f4db97a2d144ffb72da89bbe2e20d1804766f38689900/merged overlay 40G 37G 820M 98% /var/lib/docker/overlay2/095e388787b7a9c59e79531e509f9dd803d61e328c650836affa7dd110d4052f/merged shm 64M 0 64M 0% /var/lib/docker/containers/8fd937ba70f9864088e0f6a88a791ff2d1768a38c0acc68a7a51e9ca9b5dbd86/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/33dfef9c8bd1382aad26944ba6dcd946cbb9457588fa1fb81c14bd3261a024f2/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/937a5222d4a6143655844d881a3a2d7f4b42bf50c312c257b43e31d5e024e14c/mounts/shm tmpfs 184M 0 184M 0% /run/user/0  基本都是被 Docker 占用了，37G/40G。好家伙，这个 overlay 文件系统竟然这么大，看我怎么治你。\nOverlay 是什么  OverlayFS is a modern union filesystem that is similar to AUFS, but faster and with a simpler implementation.\n OverlayFS 是一个现代化的联合挂载文件系统，跟 AUFS 很像。\n什么是联合挂载呢？\n它能够将两个文件目录融合成一个，既：两个目录经过联合挂载之后，用户看到只有一个目录。\nOverlayFS 于2014年被合并到Linux内核的3.18版本。其4.0版本带来了必要的改进，例如Docker中所需的overlay2存储驱动程序。\nOverlayFS呈现其中一个所产生的对象（如果有），“上层”文件系统优先。OverlayFS与其他覆盖型文件系统不同，OverlayFS合并的目录子树不一定是来自不同的文件系统。\nOverlayFS支持在上层文件系统中的 whiteout 和 opaque 目录，以允许删除文件和目录。\nOverlay 在 Docker 中的作用 Overlay 文件系统是 Docker 中的一种 storage driver，同时 overlay2 也是官方推荐的联合挂载文件系统。\n什么是 Storage drivers  Storage drivers allow you to create data in the writable layer of your container. The files won’t be persisted after the container is deleted, and both read and write speeds are lower than native file system performance.\n Storage drivers，或者说 存储驱动（我自己翻译的，不知道对不对哈），允许在容器中创建一层可写的数据层。容器一旦被删除，这一层可写数据层也被删除，而且这层数据层的读写速度要比原生的的文件系统要慢。\n除了 overlay2 之外，Docker 还支持其他的 storage drivers:\n aufs(Another Union File System)，在老系统不支持 overlay2 时，aufs 是官方推荐的，包括Docker 18.06及以下的版本。 devicemapper btrfs and zfs vfs  Overlay 与 Overlay2 的区别  If you use OverlayFS, use the overlay2 driver rather than the overlay driver, because it is more efficient in terms of inode utilization.\n 使用 OverlayFS 最好使用 overlay2， 因为它对 inode 的使用更加有效。（这里的 inode 是某些文件系统一种记录文件的方式，可以把它当作一个数据结构，具体可以自己查阅相关资料。）\nOverlay 如何工作的  OverlayFS layers two directories on a single Linux host and presents them as a single directory. These directories are called layers and the unification process is referred to as a union mount. OverlayFS refers to the lower directory as lowerdir and the upper directory a upperdir. The unified view is exposed through its own directory called merged.\n OverlayFS 可以将两个目录「层化」（layer，注意这里是动词），并对外展示为一个单独的目录。这些被「层化」的目录叫做「层」（layers，注意这里是名词），这个统一目录的过程就叫做「union mount」（联合挂载）。\nOverlay2 如何工作的 杂谈：Overlay 的缔造者 参考 1.Use the OverlayFS storage driver 2.维基百科：OverlayFS\n","date":1568450010,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1568450010,"objectID":"afd3d26722350628665a44e0c7b85a56","permalink":"https://youngwilliamz.github.io/note/docker/storage/overlay/","publishdate":"2019-09-14T16:33:30+08:00","relpermalink":"/note/docker/storage/overlay/","section":"note","summary":"前言 最近需要把之前做的 openCredit 项目重新部署一下，发现好久不用的 aliyun 云服务器的磁盘已经快满了。\n使用 df -h 命令一看：\n➜ ~ df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 37G 820M 98% / devtmpfs 910M 0 910M 0% /dev tmpfs 920M 0 920M 0% /dev/shm tmpfs 920M 716K 919M 1% /run tmpfs 920M 0 920M 0% /sys/fs/cgroup overlay 40G 37G 820M 98% /var/lib/docker/overlay2/55aedbcf20a0380e7e03075a7a97a59869ba9c61848a28c3eb8dacc6df00e01d/merged overlay 40G 37G 820M 98% /var/lib/docker/overlay2/7bc1cd18dea024f05c9f4db97a2d144ffb72da89bbe2e20d1804766f38689900/merged overlay 40G 37G 820M 98% /var/lib/docker/overlay2/095e388787b7a9c59e79531e509f9dd803d61e328c650836affa7dd110d4052f/merged shm 64M 0 64M 0% /var/lib/docker/containers/8fd937ba70f9864088e0f6a88a791ff2d1768a38c0acc68a7a51e9ca9b5dbd86/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/33dfef9c8bd1382aad26944ba6dcd946cbb9457588fa1fb81c14bd3261a024f2/mounts/shm shm 64M 0 64M 0% /var/lib/docker/containers/937a5222d4a6143655844d881a3a2d7f4b42bf50c312c257b43e31d5e024e14c/mounts/shm tmpfs 184M 0 184M 0% /run/user/0  基本都是被 Docker 占用了，37G/40G。好家伙，这个 overlay 文件系统竟然这么大，看我怎么治你。","tags":null,"title":"Overlay 文件系统","type":"docs"},{"authors":null,"categories":null,"content":"","date":1568449131,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1568449131,"objectID":"39e1897faaf0f37d0b6f945e5614f8e6","permalink":"https://youngwilliamz.github.io/note/docker/storage/","publishdate":"2019-09-14T16:18:51+08:00","relpermalink":"/note/docker/storage/","section":"note","summary":"Docker 有多种不同的存储方法，看我能不能一一识破","tags":null,"title":"Storage 存储相关","type":"docs"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 最近开始忙秋招，「码农翻身」公众号及同名书的作者老刘在知识星球里举办了读《CSAPP》的活动，之前一直没啃下来，希望能够借此机会逼自己一把，把这本厚厚的经典看完，并好好写笔记。\n计算机系统 = 硬件 + 系统软件\n作者如是说：\n “如果你全力投身学习本书中的概念，完全理解底 层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛\u0026rdquo;的道路。”\n 看完这本书你将会学到：\n 实践技巧 优化代码小窍门 了解编译器如何实现 如何识别和避免连接时那些令人讨厌的错误 如何编写自己的 Unix shell 认识并发的陷阱  1. 信息就是「位+上下文」 hello 程序生命周期开端：hel lo.c 源文件\n 由2进制的 ASCII 编码后的字符组成  文本文件：只有ASCII字符构成的文件。如：hello.c\n二进制文件：非文本文件。\n因此，在计算机的世界中，所有的信息都是由一串比特表示。\n区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。\n2. 程序被其他程序翻译成不同的格式 hello 程序生命周期：可执行文件，或者叫「目标程序」\n编译器驱动程序：能够将「源文件」转化「目标文件」，如gcc\n例子：\nlinux\u0026gt; gee -o hello hello.c  这一过程又叫翻译，可分为四个阶段：\n执行这四个阶段的程序一起构成「编译系统」(compilation system)。\n 预处理阶段：修改源文件，得到另一个 C 程序。  删除部分#开头的命令 插入一些系统头文件，如stdio.h  编译阶段：翻译成汇编文本文件。 汇编阶段：将汇编文本文件翻译成机器语言指令，并打包成「可重定位目标程序」(relocatable object program)的格式。 链接阶段：合并一些调用的头文件，得到最终的可执行文件。  3. 了解编译系统如何工作 程序员必须知道编译系统如何工作的重要原因：\n 优化程序性能 理解连接时出现的错误 避免安全漏洞  4. 处理器读并解释储存在内存中的指令 系统的硬件：\n 总线（BUS）  贯穿整个系统的一组电子管道 通常总线被设计成传送定长的字节块，也就是字 (word)。字长是一个基本的系统参数，一般为 4 个字节( 32 位）或者 8 个字节（64位）。  I/O设备  系统与外部世界的联系通道。 每个I/O设备都通过一个控制器或适配器与I/O总线相连。  主存(Main Memory)  临时存储设备 物理上：动态随机存取储存器(DRAM)。 逻辑上：线性字节数组，每个字节都有其唯一的地址。  处理器（CPU）  解释(或执行)存储在主存中指令的引擎   运行 hello 文件：\n 在 shell 中输入./hello 之后，shell 程序将字符逐一读入寄存器，再把它放入内存。 回车后，shell知道输入完成，开始执行一系列指令来加载可执行的 hello 文件。 这些指令将 hello 目标文件从磁盘复制到内存中。 处理器将目标文件中的机器语言指令复制到寄存器中，开始解析里面的指令并执行。 数据被现实在屏幕上。  注：利用 DMA 技术可以不通过处理器而直接从磁盘到达主存。\n5. 高速缓存至关重要 上一个运行 hello 程序的例子中，信息需要依次经过：磁盘，主存，寄存器。\n这样会造成开销，减慢程序。\n因此，需要使得这些复制操作尽可能快的完成。\n6 储存设备形成层次结构 7 操作系统管理硬件 操作系统：应用程序和硬件之间插入的一层软件。\n操作系统两大基本功能：\n 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。  操作系统提供三种基本的抽象：\n 文件是对I/O设备的抽象 虚拟内存是对主存和磁盘的抽象 进程是处理器、主存和I/O设备的抽象  8 系统之间利用网络通信 网络可视为一个I/O设备。\n9 重要主题 Amdahl定律：\n并发和并行\n计算机抽象\n","date":1567348806,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1567348806,"objectID":"23c6e1040142b37c2963b6c65fc6a49c","permalink":"https://youngwilliamz.github.io/post/csapp-note-1/","publishdate":"2019-09-01T22:40:06+08:00","relpermalink":"/post/csapp-note-1/","section":"post","summary":"大四了才开始读这本书，是不是晚了？","tags":["CSAPP"],"title":"CSAPP 笔记 第一章《计算机系统漫游》","type":"post"},{"authors":null,"categories":null,"content":" 题目 难度：易\n传送门：\n English 中文  思路 一开始没有仔细看题，以为只要求出消去重复数之后数组的长度就行了，没看到还要求最后的数组。于是用了很笨的方法。\n后来看了解答，双指针，很快就出来了。\n不过，但是还是卡了一下，因为没有判断数组为空的情况。以后得引起注意啊。\n代码 时间复杂度：O(n)\n空间复杂度：O(1)\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) { return 0; } int i = 0; for (int j = 1; j \u0026lt; nums.size(); j++) { if (nums[i] != nums[j]) { i++; nums[i] = nums[j]; } } return i + 1; } };  结果 Runtime: 24 ms, faster than 59.96% of C++ online submissions\u0026hellip;.\nMemory Usage: 9.9 MB, less than 83.75% of C++ online submissions\u0026hellip;.\n可能优化的点 运行时间还是太慢，但一时找不到优化的点。\n","date":1566489506,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1566489506,"objectID":"6c9c563f3b5b9c1d844c830db2937c0b","permalink":"https://youngwilliamz.github.io/note/leetcode/array/26/","publishdate":"2019-08-22T23:58:26+08:00","relpermalink":"/note/leetcode/array/26/","section":"note","summary":"题目 难度：易\n传送门：\n English 中文  思路 一开始没有仔细看题，以为只要求出消去重复数之后数组的长度就行了，没看到还要求最后的数组。于是用了很笨的方法。\n后来看了解答，双指针，很快就出来了。\n不过，但是还是卡了一下，因为没有判断数组为空的情况。以后得引起注意啊。\n代码 时间复杂度：O(n)\n空间复杂度：O(1)\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 0) { return 0; } int i = 0; for (int j = 1; j \u0026lt; nums.size(); j++) { if (nums[i] != nums[j]) { i++; nums[i] = nums[j]; } } return i + 1; } };  结果 Runtime: 24 ms, faster than 59.96% of C++ online submissions\u0026hellip;.","tags":null,"title":"26. Remove Duplicates from Sorted Array 消去重复数","type":"docs"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 定义 可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）是IEEE为要在各种 UNIX 操作系统上运行软件，而定义 API 的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为 ISO/IEC 9945。\n来源 此标准源于一个大约开始于1985年的项目。\nPOSIX 这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。\n它基本上是 Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。\n组成 当前的POSIX主要分为四个部分：\n Base Definitions System Interfaces Shell and Utilities Rationale  POSIX 操作系统 正式认证的包括 macOS 等。\n未得到正式认证，但基本符合 POSIX 标准的有 Android、FreeBSD 等。\n参考  Wiki  ","date":1566238240,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1566238240,"objectID":"2481456e73b417a9ed50bb9e654b0040","permalink":"https://youngwilliamz.github.io/post/what-is-posix/","publishdate":"2019-08-20T02:10:40+08:00","relpermalink":"/post/what-is-posix/","section":"post","summary":"总结一下 POSIX 标准","tags":["POSIX","UNIX","LINUX"],"title":"What is POSIX?","type":"post"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" What do top students do differently?  视频连接\n 重点：\n Don\u0026rsquo;t worry about IQ. 获得高分的决定因素不是 IQ，而是方法与努力。而且或者 IQ 是天生的，是你无法控制的。 Don\u0026rsquo;t just aim to work hard. 方法至关重要，只会努力可能还会带来更坏的结果。  例子：\n 通过调查发现，考前大部分考生会一直重复地看书或者笔记，而考高分的那一部分同学则会一直做练习题。因为考试考的不是记忆，而是知识的运用。 许多人会指定短期的计划，比如一周的时间表。但实际上很少人能够坚持自己的时间表。通过研究那些能够坚持的人例子，发现他们经常会在每天某一个时间段设置一个自己喜欢的活动，比如打篮球，这样每天过的有盼头。而那些早早放弃的人一般会把时间安排的非常经凑，没有一个时间段是自己喜欢真心喜欢的（娱乐）活动，因此容易厌倦，坚持不下去。  How to learn everything | Jsoh Kaufman | TEDxCSU  视频连接\n 问题：人到中年，突然意识到没有自由时间去学习了。\n然后讲者发现：Florida State university 的一位教授，K. Anders Ericsson 最先提出 1万小时理论，即花费1万小时去学习一个新知识，最终能够成为这个领域的专家。随后还有一本书专门讲 1w 小时理论。\n但是，讲者时间有限，没有1w小时慢慢学啊。\n学习是有曲线的，前期只要一点点练习就可以达到相对高的高度。\n讲者研究出来的最有效的时间是 20 小时。\n四步学习法：\n Deconstruct the skill 分解技能/知识点。 Learn enough to self-correct Remove the practice barrier 降低学习门槛 Practice at least 20 hours 最少练习/学习 20 小时  时间分段：\n 前2小时，保证所需要的东西齐全。 开始练习  现在阻止你的不是学习的难度了，而是你想学什么？What do you want to learn？\nWhat one skill = an awesome life? | Dr. Shimi Kang  视频连接\n 一个技巧就能让你拥有一个 awesome（棒极了） 的生活?\n讲者是一位哈佛高材生、医生，但却依旧活的很累（in trouble），连三个孩子都照顾不过来，完全比不过当初成功养育她兄弟姐妹五个人的妈妈。\n她在一番思考总结之后发现，最重要的是 Adaptability（适应能力）。\n同时，她拿海豚作为例子进行讲解她总结的「POD」理论，也就是 Adaptability 的关键：\n P: Play. 儿时那种无忧无虑的玩耍，没有规则，可以随意畅想。 O: Others. Why we adapt？O 是我们适应的源头，我们需要社交，需要交流，要不然会生病，心理疾病。 D: Downtime. When we adapt? 要有一段专门放松的时间。“压力是21世纪第一病因”。  讲者提出三个单词时，都说了这个是对自己的 reward（奖励），奖励自己努力工作，努力学习。\n我的感想：\n 首先，通过这个演讲我学的最多就是讲者吐字清晰，一字一停，完全不会因为自己是 native speaker 而说的很快。而我平时喜欢说话很快，老是无法清晰的表达自己的观点。这点值得我学习。 其次，她的「POD」能够成书，还能畅销世界，我觉得实在厉害。虽然这个理论可能很多人都懂，但能够说出来，总结出来，并写成书的还是很少的。可见人与人的差距还是非常大的，而且随着现代人越来越忙，突然发现有人说「放松」、「玩耍」可以拥有更好的生活，岂不是找到偷懒的借口？  ","date":1566010135,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1566010135,"objectID":"5e6bcca7c168134fc9bae6ff9e711d3e","permalink":"https://youngwilliamz.github.io/post/ted/","publishdate":"2019-08-17T02:48:55Z","relpermalink":"/post/ted/","section":"post","summary":"我的 TED 观影笔记，希望以后能保持经常更新～","tags":["TED","思维方式","笔记"],"title":"TED 演讲吸收笔记与总结","type":"post"},{"authors":null,"categories":null,"content":" 题目 难度：易\n给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在众数。\n示例 1:\n输入: [3,2,3] 输出: 3  示例 2:\n输入: [2,2,1,1,1,2,2] 输出: 2  传送门：\n English 中文  思路    算法 时间复杂度 空间复杂度     暴力 O(n^2) O(n)   哈希表 O(n) O(n)   排序 O(nlogn) O(1)   分治 O(nlogn) O(logn)   Boyer-Moore 投票算法 O(n) O(1)    分治 一分为二，求两边众数的次数，很复杂。\nBoyer-Moore 投票算法 寻找数组中超过一半的数字，这意味着数组中其他数字出现次数的总和都是比不上这个数字出现的次数\n即如果把 该众数记为 +1 ，把其他数记为 −1 ，将它们全部加起来，和是大于 0 的。\n代码 大致操作：\n 设置两个变量 candidate 和 count，candidate 用来保存数组中遍历到的某个数字，count 表示当前数字的出现次数，一开始 candidate 保存为数组中的第一个数字，count 为 1\n 遍历整个数组\n 如果数字与之前 candidate 保存的数字相同，则 count 加 1\n 如果数字与之前 candidate 保存的数字不同，则 count 减 1\n 如果出现次数 count 变为 0 ，candidate 进行变化，保存为当前遍历的那个数字，并且同时把 count 重置为 1（这里是细节，同时也需要好好理解）\n 遍历完数组中的所有数字即可得到结果\n   参考：https://leetcode-cn.com/problems/two-sum/solution/du-le-le-bu-ru-zhong-le-le-ru-he-zhuang-bi-de-q\nclass Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int candidate = nums[0]; int counter = 1; for (int i = 1; i \u0026lt; nums.size(); i++) { if (nums[i] == candidate) { ++counter; } else { --counter; } if (counter == 0) { candidate = nums[i]; counter = 1; } } return candidate; } };  小结 这种题的最优解普通人的很难想到，既简单又高效，这个摩尔有点东西。果然还是得多刷题，不过这道题得注意一下细节。\n","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"382b24e6813157cbac13546544fb027d","permalink":"https://youngwilliamz.github.io/note/leetcode/array/169/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/array/169/","section":"note","summary":"题目 难度：易\n给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在众数。\n示例 1:\n输入: [3,2,3] 输出: 3  示例 2:\n输入: [2,2,1,1,1,2,2] 输出: 2  传送门：\n English 中文  思路    算法 时间复杂度 空间复杂度     暴力 O(n^2) O(n)   哈希表 O(n) O(n)   排序 O(nlogn) O(1)   分治 O(nlogn) O(logn)   Boyer-Moore 投票算法 O(n) O(1)    分治 一分为二，求两边众数的次数，很复杂。","tags":null,"title":"169. Majority Element 求众数","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"48a899d50d972161ba5e150886aecc65","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter1-array/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter1-array/","section":"note","summary":"","tags":null,"title":"Array 数组","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"43f1e8706065f42e36eaf79a959cc3e2","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter7/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter7/","section":"note","summary":"","tags":null,"title":"Desgin 设计","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"fa958d18da050146c970f7bc408b778b","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter6/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter6/","section":"note","summary":"","tags":null,"title":"Dynamic Programming 动态规划","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"8c31a9297624190e848524afb3b2d2aa","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter3-linked-list/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter3-linked-list/","section":"note","summary":"","tags":null,"title":"Linked List 链表","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"07feb7c771c04c4830bef02d418a7292","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter8/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter8/","section":"note","summary":"","tags":null,"title":"Math 数学","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"e020935897071ff02543f5e92b22f7e8","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter9/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter9/","section":"note","summary":"","tags":null,"title":"Others 其他","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"f067b0fc827090ba4dfe9a98e6f01965","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter5-sorting-searching/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter5-sorting-searching/","section":"note","summary":"","tags":null,"title":"Sorting \u0026 Searching 排序与搜索","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"2d84a6aeb462d462df74381fa1db397c","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter2/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter2/","section":"note","summary":"","tags":null,"title":"String 字符串","type":"docs"},{"authors":null,"categories":null,"content":"","date":1565711906,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565711906,"objectID":"185d6601e310dc9a7104a541edd18013","permalink":"https://youngwilliamz.github.io/note/leetcode/chapter4/","publishdate":"2019-08-13T23:58:26+08:00","relpermalink":"/note/leetcode/chapter4/","section":"note","summary":"","tags":null,"title":"Tree 树","type":"docs"},{"authors":["YoungWilliam"],"categories":[],"content":"","date":1565709649,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565709649,"objectID":"050f444fe2cac381168e37b5e0192f89","permalink":"https://youngwilliamz.github.io/project/opencredit/","publishdate":"2019-08-13T23:20:49+08:00","relpermalink":"/project/opencredit/","section":"project","summary":"基于 FISCO-BCOS 框架（继承以太坊技术体系）实现的去中心化征信系统。","tags":["Blockchain"],"title":"OpenCredit","type":"project"},{"authors":["YoungWilliam"],"categories":["学习"],"content":"","date":1565459386,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565459386,"objectID":"091404ffd6bf34f3231d751b33c3abac","permalink":"https://youngwilliamz.github.io/project/mydocker/","publishdate":"2019-08-11T01:49:46+08:00","relpermalink":"/project/mydocker/","section":"project","summary":"希望借此记录并学习 Docker 的内部构造","tags":["Docker"],"title":"从 0 实现 Docker","type":"project"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 为什么要有 /proc？ 想必在日常开发写查 BUG 中，你会经常用到像 top、ps 这样的 Linux 命令来查看进程、CPU 的状态吧。\n那你是否有想过：这些不都是内核才知道的吗？而作为身处 shell （用户态）的我们又是通过什么途径知道这些的呢？\n是有什么 system call 吗？是有什么高级的接口吗？\n不不不，其实是通过一个神奇的目录，也就是今天的主角 /proc。\n实际上，top 中的数据就是读取 /proc/stat 文件获得的，/proc/stat 文件被读取时会自动更新，从而 top 获得最新的 CPU 占用率情况。\n/proc 是什么？ /proc 其实不是一个“真正”的文件目录，而是一个“虚拟”的文件系统（virtual filesystem）。\n为什么是虚拟的呢？因为它不写入外存空间，只存在于内存中。\n它包含了系统运行时的信息，包括：\n 当前运行进程信息 系统内存 mount 设备信息 一些硬件配置 \u0026hellip;等。  因此，可以把它当作内核的信息中心。\n当然许多系统工具都是通过简单读取该目录下的某些内容。\n比如：\n lsmod = cat /proc/modules lspci = cat /proc/pci  在系统正在运行时，你甚至可以通过修改 /proc 目录下文件，来读取修改系统的内核参数（sysctl）。\n/proc 基本目录结构 因为文件都在内存中，如果你去看每个文件的大小，你会发现都是 0，除了 kcore, mtrr and self。\n当遍历这个目录的时候，会发现有些数字，这些都是为每个进程创建的空间，数字就是它们的 PID。\n[go_dev@0f8b372ed635 proc]$ ll /proc total 0 dr-xr-xr-x 9 go_dev go_dev 0 Aug 1 18:43 1 dr-xr-xr-x 9 go_dev go_dev 0 Aug 1 18:44 30 drwxrwxrwt 2 root root 40 Aug 1 18:43 acpi -r--r--r-- 1 root root 0 Aug 1 18:44 buddyinfo dr-xr-xr-x 4 root root 0 Aug 1 18:43 bus -r--r--r-- 1 root root 0 Aug 1 18:44 cgroups -r--r--r-- 1 root root 0 Aug 1 18:44 cmdline -r--r--r-- 1 root root 23709 Aug 1 18:44 config.gz -r--r--r-- 1 root root 0 Aug 1 18:44 consoles -r--r--r-- 1 root root 0 Aug 1 18:44 cpuinfo -r--r--r-- 1 root root 0 Aug 1 18:44 crypto -r--r--r-- 1 root root 0 Aug 1 18:44 devices -r--r--r-- 1 root root 0 Aug 1 18:44 diskstats -r--r--r-- 1 root root 0 Aug 1 18:44 dma dr-xr-xr-x 2 root root 0 Aug 1 18:44 driver -r--r--r-- 1 root root 0 Aug 1 18:44 execdomains -r--r--r-- 1 root root 0 Aug 1 18:44 fb -r--r--r-- 1 root root 0 Aug 1 18:44 filesystems dr-xr-xr-x 8 root root 0 Aug 1 18:43 fs -r--r--r-- 1 root root 0 Aug 1 18:44 interrupts -r--r--r-- 1 root root 0 Aug 1 18:44 iomem -r--r--r-- 1 root root 0 Aug 1 18:44 ioports dr-xr-xr-x 31 root root 0 Aug 1 18:43 irq -r--r--r-- 1 root root 0 Aug 1 18:44 kallsyms crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 kcore -r--r--r-- 1 root root 0 Aug 1 18:44 key-users crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 keys -r-------- 1 root root 0 Aug 1 18:44 kmsg -r-------- 1 root root 0 Aug 1 18:44 kpagecgroup -r-------- 1 root root 0 Aug 1 18:44 kpagecount -r-------- 1 root root 0 Aug 1 18:44 kpageflags -r--r--r-- 1 root root 0 Aug 1 18:44 loadavg -r--r--r-- 1 root root 0 Aug 1 18:44 locks -r--r--r-- 1 root root 0 Aug 1 18:44 meminfo -r--r--r-- 1 root root 0 Aug 1 18:44 misc -r--r--r-- 1 root root 0 Aug 1 18:44 modules lrwxrwxrwx 1 root root 11 Aug 1 18:44 mounts -\u0026gt; self/mounts dr-xr-xr-x 2 root root 0 Aug 1 18:44 mpt -rw-r--r-- 1 root root 0 Aug 1 18:44 mtrr lrwxrwxrwx 1 root root 8 Aug 1 18:44 net -\u0026gt; self/net -r--r--r-- 1 root root 0 Aug 1 18:44 pagetypeinfo -r--r--r-- 1 root root 0 Aug 1 18:44 partitions crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 sched_debug lrwxrwxrwx 1 root root 0 Aug 1 18:43 self -\u0026gt; 30 -rw------- 1 root root 0 Aug 1 18:44 slabinfo -r--r--r-- 1 root root 0 Aug 1 18:44 softirqs -r--r--r-- 1 root root 0 Aug 1 18:44 stat -r--r--r-- 1 root root 0 Aug 1 18:44 swaps dr-xr-xr-x 1 root root 0 Aug 1 18:43 sys --w------- 1 root root 0 Aug 1 18:43 sysrq-trigger dr-xr-xr-x 2 root root 0 Aug 1 18:44 sysvipc lrwxrwxrwx 1 root root 0 Aug 1 18:43 thread-self -\u0026gt; 30/task/30 crw-rw-rw- 1 root root 1, 3 Aug 1 18:43 timer_list dr-xr-xr-x 4 root root 0 Aug 1 18:44 tty -r--r--r-- 1 root root 0 Aug 1 18:44 uptime -r--r--r-- 1 root root 0 Aug 1 18:44 version -r-------- 1 root root 0 Aug 1 18:44 vmallocinfo -r--r--r-- 1 root root 0 Aug 1 18:44 vmstat -r--r--r-- 1 root root 0 Aug 1 18:44 zoneinfo  在此介绍几个比较重要的部分：\n   /proc/N PID 为 N 的进程信息     /proc/N/cmdline 进程启动命令   /proc/N/cwd 链接到进程当前工作目录   /proc/N/environ 进程环境变量列表   /proc/N/exe 链接到进程的执行命令文件   /proc/N/fd 包含进程相关的所有文件描述符   /proc/N/maps 与进程相关的内存映射信息   /proc/N/mem 指代进程持有的内存，不可读   /proc/N/root 链接到进程的根目录   /proc/N/stat 进程的状态   /proc/N/statm 进程使用的内存状态   /proc/N/status 进程状态信息，比 stat/statm 更具可读性   /proc/self/ 链接到当前正在运行的进程    如果像了解更多的话，请自行 google 或者看看 Linux Filesystem Hierarchy: 1.14. /proc。\nDocker 如何利用到 /proc？ 参考  Linux Filesystem Hierarchy: 1.14. /proc 《自己动手写Docker》\n wiki: procfs\n  ","date":1564711449,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1564711449,"objectID":"9c30e1535be0f93924665488a826dd32","permalink":"https://youngwilliamz.github.io/post/linux-proc/","publishdate":"2019-08-02T02:04:09Z","relpermalink":"/post/linux-proc/","section":"post","summary":"我的 Docker 原理探索之路","tags":["linux","docker","proc"],"title":"Docker 背后： Linux 的 /proc","type":"post"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 还没好好看一遍《剑指Offer》，希望在阅读的过程中能记录一下，同时也方便以后复习。\n3. 高质量的代码 3.2 代码的规范性 代码的完整性:  功能测试：要满足基本功能、尽量突破常规思维的限制 边界测试：考虑循环、递归终止条件；字符串转整数时确保极大极小值等。 负面测试：各种可能的错误输入  3 种错误处理的方法：     优点 缺点     返回值 和系统 API 一致，0 为正常，其他为错误 不能方便使用计算结果   全局变量 可以直接得到计算结果，方便使用 很容易忘记检查   异常 逻辑清晰，明确定义错误类型 一些语言不支持，对性能有负面影响    具体用哪种需要考虑具体场景，可以和面试讨论一下采用哪种比较合适。\n","date":1564337845,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1564337845,"objectID":"7dcc94958f48e1c1dea3c9e086e2b1ac","permalink":"https://youngwilliamz.github.io/post/coding-interviews-note-1/","publishdate":"2019-07-28T18:17:25Z","relpermalink":"/post/coding-interviews-note-1/","section":"post","summary":"《剑指Offer》笔记，不定时更新～","tags":["笔记","剑指Offer"],"title":"《剑指Offer》笔记","type":"post"},{"authors":["YoungWilliam"],"categories":["搞机"],"content":"  此方案已失败，但还是可以参考的，说不定你就成功了？\n 宿舍的路由器一直不太好用，今天把之前买的 K2P 重新刷了 OpenWRT 新版系统。WAN 6 可以获取到 IPv6 的公网地址，可是发现 LAN 口只能获取本地的 IPv6，用不了，连不上北邮人，每次都得切到 SUSTC-Wifi 才能连，实在非常不方便。于是就研究了几小时绕了一大圈才找到可行的解决办法。在此记录下。\nWAN 6 设置 协议：DHCPv6 客户端 请求 IPv6 地址：try（不能选 force）\nLAN 设置 最下面 DHCP 服务器 中 IPv6 设置 下：\n 路由通告服务、DHCPv6 服务、NDP 代理全部选为混合模式。这样 WAN 6 和 LAN 就都可以获得公网 IPv6。 DHCPv6 模式 选择 无状态的 + 有状态的  “上面「一般配置-物理设置」，找到「接口」，点击最右边的小三角，弹出下拉菜单。默认这里「交换机 VLAN eth0.2 (lan, wan, wan6)」是没有选上的吧？勾选上这个。为啥选这个呢？因为它有 wan6 哇～”\n保存并应用。等一段时间还没有生效的话，就重启。我是重启完立马就有了原生 IPv6。\n主要参考 OpenWrt IPv6 中继\nPS 我自己在之前的教程中修改了 /etc/config/dhcp，不知道有没有影响。 只是在config dhcp 'lan' 的最下面添加了 option master '1'。如果上诉方法对你不起作用，可以试试这个或者使用 NAT。\n","date":1552211335,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1552211335,"objectID":"45f21fe8d0a52a6369905f91000d89e5","permalink":"https://youngwilliamz.github.io/post/openwrt-ipv6-relay/","publishdate":"2019-03-10T09:48:55Z","relpermalink":"/post/openwrt-ipv6-relay/","section":"post","summary":"此方案失败了，但还是可以参考的，说不定你就成功了？","tags":["OpenWRT","IPv6"],"title":"OpenWRT 18.06 IPv6 开启 Relay，LAN 口获取 IPv6 公网地址","type":"post"},{"authors":["YoungWilliam"],"categories":["学习"],"content":" 目录 HAHAHUGOSHORTCODE-TOC0-HBHB\n背景 这门课是张哥（stormzhang）在朋友圈推荐的，买的话可以直接进入 Caoz 的星球。我主要是冲着星球去的，因为星球价值真的高啊。其实之前本来就打算进星球的，无奈刚换电脑，比较拮据，就只好等待机会。进了星球，发现一堆创业大佬，就是一个人脉圈啊，有没有作用，就看你的本事了。以上就是星球附赠的课程《成长的烦恼》的由来。因为时间限制，28 号晚上就会无法访问，就想称此机会好好读读。\n1. 读书时代 1.1. 尽早确立职场目标并准备 曹大在这里描述了一下自己的学生生涯，悔恨自己当初没有好好学好专业课，以至于错失许多机会。\n摘录：\n 对于专业技能，特别是计算机的专业技能，我建议是一精多通：你能在某个特定领域达到足够的高度，而其他相关领域达到一定的标准。原因：\n 需要跟不同领域的人沟通时，更好地理解对方，换位思考，降低沟通成本。 可以在特殊情况下自己干。 企业喜欢这种全才。   1.2. 切忌陷入自以为是的境地  为什么自以为是？信息获取的渠道很窄。=》价值观趋同，社会认知趋同。\n很多真正很有价值的真相，在读书的时候是看不见的。你从媒体看互联网，你从那些成功者的演说里看互联网，你是看不到真相的。\n如何解决？ 多跟不同人群沟通。 尽早实习，多跟不同部门沟通。\n例子1: 遇到没有听说过的的公司可以去搜一下资料，\u0008并且听听他们的宣讲。 “今天见到李开复咯，收获好大哦～收获了啥呢？朋友圈的赞。。。”\n 1.3. 基础思想和逻辑需要尽早培养 \u0008理解公式来锻炼自己的理解能力。\n世界上大部分人不\u0008具备逻辑能力。无法用最优解的思想去思考。\n\u0008学好基础，\u0008培养思想，而不是\u0008去学工具。\n2. 关于求职  经常的错误：\u0008不尊重职场。 求职前要有\u0008准备，要调研，要在简历中体现你的准备和思考。\n 要谦虚\u0008和积极。 愿意从基层做起，从小事做起。\n 职场要体面一点。 初次相遇，一切重要场合还是需要的。\n 面试问问题。要有准备。基于企业的公开信息进行提问，挖掘出深度问题。\n  3. 个人职场定位 3.1. 找到个人专长 \u0008\u0008“\u0008看上去很全能，其实不堪一击。\u0008”\n3.2. 好奇心是动力之源 “一定要知道自己最痴迷什么？”\n“我是怎么甄别信息的，其实很简单，就是好奇心。对某一个新闻，有些人有好奇心就会去挖掘这些信息，而大多数人是不关心的。”\n3.3. 要建立全局意识和整体感 “对行业、专业的要有认知，\u0008知道机会和方向在哪儿，要知道自己更上台阶\u0008需要去哪儿。”\n“所以我经常建议年轻人，读书的，没毕业的或刚毕业的多多看看行业内顶尖企业的财报，了解行业发展的规模/竞争态势。”\n“新兴\u0008领域\u0008、新兴机会也要多看看，比如百度的\u0008热榜，爱站指数，认真挖掘，对行业认知的\u0008其实会增加许多。”\n提到几位人物：余军、边江、高少星\n“多去了解企业整体架构。了解公司的核心价值和主要方向。”\n“职场秘密：\u0008快速拓展的公司，很多\u0008中层为了自己的发展，快速启动新的项目团队，每个项目看上去都很有价值很有机会，\u0008\u0008然后大家忙忙碌碌为了新的机会各种打拼。但是，其实从公司战略和格局来说，绝大多数都是试验品、甚至是垃圾。等到市场风向逆转的时候，老板开始核查成本，这些乱七八糟的玩意儿全部砍掉。\u0008你觉自己很拼，很有贡献，可在老板眼里一文不值。”\n“\u0008一定要站的高一点，站在上司的位置\u0008看问题，看机会，看方向。如果看不到，多问！”\n“把四五个人的工作量\u0008给一个人做，可能会发现只有少数的事有必要做。”\n佩服的人：李兴平，做网站特别强。在没有\u0008资源的情况下，比专业人士\u0008做的好。\n3.4. 关于个人待遇的话题 \u0008“职场定位，你要对自己的发展\u0008目标有整体的\u0008认识。”\n 发展期：20-30 关注成长，只有吃苦。\u0008只有少数人能真正踩对路，少走弯路。 成熟期：30-35 达到Top10% 提高企业职位、提高业界影响力、建立人脉。  “不需要顶尖水平，因为很多顶尖水平的人没意识到这一点。\u0008” “达到领域内 Top 10% 并不难，绝大部分\u0008人又懒又爱给自己找借口。”  变现期：35之后务必快速走入变现期。能力够了，影响力和口碑够了。\u0008这个时候就要让自己价值最大化。  索要期权，知道整个期权的比例。\u0008要有概念。\n创业要\u0008确定好退出条款。毕竟「\u0008能共患难，不一定能共享福。」\n3.5. 互相成就 写工作报告的时候将帮助过自己的人写进去，不仅可以帮助别人，对自己也没什么损失，\u0008何乐而不为呢？\n4. 谈谈创业 这个部分曹大\u0008讲了许多\u0008自己的例子。大部分内容在曹大的文章都有提及，就不一一粘贴了。\u0008\n4.1. 创业需要视野和格局 “\u0008所以创业有几个教训：1. 居安思危，眼光要长远。 2. 动作要快，行动力要强。 3. 必要的时候需要魄力，需要团队，需要资金，不能当干。单干格局太低。\u0008”\n“\u0008你写了很多代码，很酷的技术，\u0008没有人用，很少人用，你技术再牛又怎么样呢？\u0008你代码很简单，被广泛用起来，而且为别人真正带来了价值，你的工作就是很有价值。”\n创业历程：\n 上世纪末：  \u0008交换链。错失 hao123  2004：  OA系统，一个人\u0008，安装包压缩到 5m。代码量大，但用的人不多。 统计系统。代码量少，但很多人用。\u0008   4.2. 创业需要懂得价值评估 4.3. 更好的理解人性 4.4. 财务和数据 5. 总结与回复 \u00086. \u0008最后的感受 \u0008这是我自己听完曹大课的感受。\u0008曹大在这期课程里着重强调了\u0008看待事物的全局观和自己的好奇心。\u0008\n先说说\u0008全局观，\u0008我觉得全局观\u0008就是在多个角度想问题：从领导角度也好，从别的部门角度也好，总之就是\u0008多\u0008想想，多看看\u0008，\u0008搞明白市场的变化方向，理解\u0008最重要的核心，\u0008\u0008理解好利益冲突。\n\u0008再说说好奇心，曹大的信息筛选全凭好奇心。\u0008而曹大的好奇心有点\u0008跟我的不太一样，他对许多未知的事物都感到好奇，希望更多地了解，会从一则小新闻里衍生地去查很多相关资料。\n另外说一句，有实效性的课程真的能够克服懒癌，能够逼着自己去读完听完而不浪费难得的机会。想想躺在书架上的那么多书还没怎么翻过，还有「\u0008极客时间」里的\u0008\u0008十几个课程还只看了一点点，\u0008而我却没有一丝愧疚。\u0008\u0008\u0008\u0008可能我还不够优秀吧。\n","date":1546033735,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546033735,"objectID":"8175b713802bf72e63d932821f0d7eef","permalink":"https://youngwilliamz.github.io/post/caoz-class-node/","publishdate":"2018-12-28T21:48:55Z","relpermalink":"/post/caoz-class-node/","section":"post","summary":"匆匆读一下 CaoZ 大佬在「易灵微课」开通的《成长的烦恼》笔记","tags":["Caoz","思维方式"],"title":"Caoz《成长的烦恼》笔记","type":"post"},{"authors":["YoungWilliam"],"categories":["搞事"],"content":"","date":1539444736,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1539444736,"objectID":"766d0b98d87e809ba1e65b547989993f","permalink":"https://youngwilliamz.github.io/project/sustctong/","publishdate":"2018-10-13T23:32:16+08:00","relpermalink":"/project/sustctong/","section":"project","summary":"为南科大（SUSTech）的师生提供方便的信息查询，包括校园巴士时间、课程表信息等。","tags":["微信小程序"],"title":"南科通 微信小程序","type":"project"},{"authors":["YoungWilliam"],"categories":["工欲善其事"],"content":" 先上最终效果图：\n\u0008目录  \u0008目录 1. 相关工具介绍 2. 配置总览 3. 安装步骤  3.1. 安装 iTerm2 3.2. 安装XCode’s Command line tools 3.3. 检查 zsh 是否已安装 3.4. 安装 Oh-My-Zsh 3.5. 安装 Powerline fonts 3.6. 安装配置主题 3.7. 修改命令提示符 3.8. 配置 zsh 命令语法高亮  4. 备用下载链接 5. 参考及感谢  1. 相关工具介绍  iTerm2： Terminal 终端的替代品，拥有更多强大的功能，想了解更多请戳 iTerm2 官网； XCode’s Command line tools: 开发环境集成，包含 git、gcc 等重要工具； zsh：Linux 的一种 shell 外壳，强大的虚拟终端，和 bash 属于同类产品，OS X 已自带； Oh-My-Zsh: 用来管理 zsh 的配置，同时还有很多社区贡献的主题配置以及好用的插件可供使用，了解更多请戳 Oh-My-Zsh 官网；  2. 配置总览  iTerm2 Oh-My-Zsh agnoster 主题 zsh 命令语法高亮  3. 安装步骤 3.1. 安装 iTerm2 进入官网下载页面，点击 Stable Releases 下面的 Download 即可下载，解压后拖到应用程序中。这是简单的一小步，但是却是优化 Terminal 的一大步！\nPS: 网络环境不太好的同学不要担心，我已经把安装包传到百度云了，请到文章最后寻找链接下载。\n3.2. 安装XCode’s Command line tools XCode 13 个 G ,这里我们只需要 XCode’s Command line tools 来支撑 Git 的使用，所以我们不用费时费力装 XCode 来浪费那13个G。 (从 Yosemite（10.10+）开始，Command Line Tools 可以单独安装。)\n安装方法: 打开终端，输入\nxcode-select –install  点 install ，同意，即可。\n3.3. 检查 zsh 是否已安装 在命令行输入：\nzsh --version  如果显示\nzsh 5.3 (x86_64-apple-darwin17.0)  即zsh的当前版本号，就说明装好了，一般 OS X 自带有的。\n如果没装则需要输入：\nbrew install zsh zsh-completions  这是用Homebrew装，需要 OS X 上有Homebrew，它的网站：https://brew.sh/\n3.4. 安装 Oh-My-Zsh 可以通过 curl 或者 wget 来安装\n curl\nsh -c \u0026quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;  wget\nsh -c \u0026quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;   网络好的话几秒就装好了。\n一般安装程序会自动把默认的 shell 切换为 zsh, 什么！你不懂 shell 是什么？我也不懂，你去问问度娘？或者直接右上角？其实不懂也正常，也不影响你拥有自己美美的终端。\n如果想修改默认 shell 为原来的 bash：\nchsh -s /bin/bash  重启 iTerm2 就好了。\n3.5. 安装 Powerline fonts 华丽丽的主题需要 Powerline 字符集的支持。 通过 git 安装, 直接执行以下命令行：\ngit clone https://github.com/powerline/fonts.git --depth=1; cd fonts; ./install.sh; cd ..; rm -rf fonts  然后到 iterm2 配置，设置字体 1. 打开 Preferences，选择 Profiles 2. 选择 Text，点击 Change Font 3. 选择固定宽度，选择自己喜欢的字体。注意： iTerm2 可以实时看到效果，结尾不是 for Powerline 的会乱码。 4. 接着修改字体颜色，选择另一项 Colors, 点击 Color Presets, 选择Solarized Dark 3.6. 安装配置主题 装好之后就可以换到 agnoster 主题，Oh My Zsh 一般自带有这个主题。\n可以看看其它的默认主题：\nls ~/.oh-my-zsh/themes  需要修改主题只需：\nvim ~/.zshrc  然后把里面 ZSH_THEME 的值改为 ZSH_THEME=\u0026ldquo;agnoster\u0026rdquo;，保存退出。\n修改和保存的过程为： 1. 按下 i 开始编辑 2. 通过方向键控制光标的位置 3. 定位到 ZSH_THEME 4. 改为 ZSH_THEME=\u0026quot;agnoster\u0026quot; 5. 按下 ESC, 输入 :wq, 回车 6. 搞定！\n（点击这里还有各种主题预览，任君翻牌~）\n3.7. 修改命令提示符 默认的命令提示符为 user@userdemackbookPro，这样的提示符配合 powerlevel9k 主题太过冗长，因此我选择将该冗长的提示符去掉，在 ~/.zshrc 配置文件后面追加如下内容：\n# 注意：DEFAULT_USER 的值必须要是系统用户名才能生效 DEFAULT_USER=\u0026quot;user\u0026quot;  编辑方法同上。\n3.8. 配置 zsh 命令语法高亮 zsh-syntax-highlighting 插件可以使你终端输入的命令有语法高亮效果，安装方法如下（oh-my-zsh 插件管理的方式安装）： 1. 复制文件到插件目录 bash git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting  2. 修改 ~/.zshrc 添加插件 bash # 注意：zsh-syntax-highlighting 必须放在最后面（官方推荐） plugins=( [plugins...] zsh-syntax-highlighting)   应用修改\nsource ~/.zshrc   大功告成~有问题欢迎留言讨论~\n4. 备用下载链接 iTerm2 ( 3.2.0 )： 链接: https://pan.baidu.com/s/1Wm7NjtGfA81LpGFYAaEAPQ 密码: ksgv\n5. 参考及感谢  我的 Mac 终端配置（Mac OSX + iTerm2 + Zsh + Oh-My-Zsh） iTerm2 + OhMyZsh + agnoster + Powerline + solarized = 漂亮的Mac终端  ","date":1533995520,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1533995520,"objectID":"42f6102424f12658cdb39d212c149451","permalink":"https://youngwilliamz.github.io/post/optimize-the-terminal-in-mac-os-x/","publishdate":"2018-08-11T13:52:00Z","relpermalink":"/post/optimize-the-terminal-in-mac-os-x/","section":"post","summary":"Mac 大法好","tags":["Max OS X"],"title":"Mac OS X 下优化 Terminal，一篇就够了！","type":"post"},{"authors":["YoungWilliam"],"categories":["Markdown"],"content":" 目录 HAHAHUGOSHORTCODE-TOC0-HBHB\n总结一下，Hexo 下 Markdown 的写法和一些奇技淫巧。\n说明：Hexo 主题为 Next\n标题及分类 格式：(使用 HexoEditor 新建Post 可以自动生成以下内容)\n--- title: Hexo 使用 Markdown 编辑技巧大全 tags: - Hexo - Markdown categories: - Markdown date: 2018-07-10 15:29:00 ---  阅读更多 Hexo 主页每篇文章可以显示 Read More 按钮，只显示以下这一行以上的文章内容。 格式：\n\u0026lt;!-- more --\u0026gt;  Markdown 语法 Markdown 语法主要分为如下几大部分： * 标题 * 段落 * 区块引用 * 代码区块 * 强调 * 列表 * 分割线 * 链接 * 图片 * 反斜杠 \\ * 符号\u0026rsquo;`\u0026rsquo;\n标题 两种形式：\n1）使用=和-标记一级和二级标题。 \u0026gt; 一级标题\n\u0026gt; =========\n\u0026gt; 二级标题\n\u0026gt; ---------\n效果： \u0026gt; 一级标题\n\u0026gt; =========\n\u0026gt; 二级标题 \u0026gt; \u0026mdash;\u0026mdash;\u0026mdash;\n2）使用#，可表示1-6级标题。 \u0026gt; # 一级标题\n\u0026gt; ## 二级标题\n\u0026gt; ### 三级标题\n\u0026gt; #### 四级标题\n\u0026gt; ##### 五级标题\n\u0026gt; ###### 六级标题\n效果： \u0026gt; # 一级标题\n\u0026gt; ## 二级标题\n\u0026gt; ### 三级标题\n\u0026gt; #### 四级标题\n\u0026gt; ##### 五级标题\n\u0026gt; ###### 六级标题\n段落 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。\n区块引用 在段落的每行或者只在第一行使用符号\u0026gt;,还可使用多个嵌套引用，如： \u0026gt; \u0026gt; 区块引用\n\u0026gt; \u0026gt;\u0026gt; 嵌套引用\n效果： \u0026gt; 区块引用\n\u0026gt;\u0026gt; 嵌套引用\n代码区块 代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如\n普通段落：\nvoid main()\n{\nprintf(\u0026ldquo;Hello, Markdown.\u0026rdquo;);\n}\n代码区块： 如： \u0026gt; ``` C \u0026gt; void main() \u0026gt; { \u0026gt; printf(\u0026ldquo;Hello, Markdown.\u0026rdquo;); \u0026gt; } \u0026gt; ```\n效果：\nvoid main() { printf(\u0026quot;Hello, Markdown.\u0026quot;); }  注意: ``` 之后可以添加语言种类如 C、Java、Bash, 需要和普通段落之间存在空行。\n强调 在强调内容两侧分别加上*或者_，如： \u0026gt; *斜体*，_斜体_\n\u0026gt; **粗体**，__粗体__\n效果： \u0026gt; *斜体*，斜体\n\u0026gt; 粗体，粗体\n列表 使用·、+、或-标记无序列表，如： \u0026gt; -（+*） 第一项 \u0026gt; -（+*） 第二项 \u0026gt; - （+*）第三项\n注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n效果： \u0026gt; + 第一项 \u0026gt; + 第二项 \u0026gt; + 第三项\n有序列表的标记方式是将上述的符号换成数字,并辅以.，如： \u0026gt; 1 . 第一项\n\u0026gt; 2 . 第二项\n\u0026gt; 3 . 第三项\n效果： \u0026gt; 1. 第一项 \u0026gt; 2. 第二项 \u0026gt; 3. 第三项\n分割线 分割线最常使用就是三个或以上*，还可以使用-和_。\n链接 链接可以由两种形式生成：行内式和参考式。\n行内式： \u0026gt; [YoungWilliam的博客](https://youngwilliamz.github.io/)\n效果： \u0026gt; YoungWilliam的博客\n参考式： \u0026gt; [YoungWilliam的博客1][1]\n\u0026gt; [YoungWilliam的博客2][2]\n\u0026gt; [1]:https://youngwilliamz.github.io/ \u0026gt; [2]:https://youngwilliamz.github.io/\n效果： \u0026gt; YoungWilliam的博客1\n\u0026gt; YoungWilliam的博客2\n\u0026gt; YoungWilliam的博客3\n注意：上述的[1]:https://youngwilliamz.github.io/不出现在区块中。\n图片 添加图片的形式和链接相似，只需在链接的基础上前方加一个！。\n反斜杠\\ 相当于反转义作用。使符号成为普通符号。\n符号 ` 起到标记作用。如： \u0026gt;`ctrl+a`\n效果： \u0026gt;ctrl+a\n注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。 虽然有人想出面搞一个所谓的标准化的Markdown，没想到还惹怒了健在的创始人John Gruber。\n以上基本是所有traditonal markdown的语法。\n其它 列表的使用(非traditonal markdown)：\n用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 格式：\n|代码库 |链接 | |:------------------------------------:|------------------------------------| |MarkDown |[https://github.com/younghz/Markdown](https://github.com/younghz/Markdown \u0026quot;Markdown\u0026quot;)| |MarkDownCopy |[https://github.com/younghz/Markdown](https://github.com/younghz/Markdown \u0026quot;Markdown\u0026quot;)|  效果:\n   代码库 链接     MarkDown https://github.com/younghz/Markdown   MarkDownCopy https://github.com/younghz/Markdown    关于其它扩展语法可参见具体工具的使用说明。\n参考文章 Markdown 基本语法\n","date":1531236540,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1531236540,"objectID":"4c84adadbff99c9c09c6fc3816fcd9df","permalink":"https://youngwilliamz.github.io/post/hexo-markdown/","publishdate":"2018-07-10T15:29:00Z","relpermalink":"/post/hexo-markdown/","section":"post","summary":"可能还不全，哈哈哈，看官请随意。","tags":["Hexo","Markdown"],"title":"Hexo 使用 Markdown 编辑技巧大全","type":"post"},{"authors":["YoungWilliam"],"categories":["Hexo"],"content":"直接上代码，src对应的是图片 url\n\u0026lt;img src=\u0026quot;https://i.loli.net/2018/06/24/5b2edf5139f61.png\u0026quot; width=\u0026quot;50%\u0026quot; height=\u0026quot;50%\u0026quot;\u0026gt;  效果图如下：（使用的是 SM.MS图床）\n","date":1529827320,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1529827320,"objectID":"b4d76c3e309e35b1b743a8b907e16b6d","permalink":"https://youngwilliamz.github.io/post/hexo-image-edite-method/","publishdate":"2018-06-24T08:02:00Z","relpermalink":"/post/hexo-image-edite-method/","section":"post","summary":"Hexo 小技巧","tags":["Hexo","Markdown"],"title":"Hexo 下特有的编辑图片方式，直接使用 img 标志","type":"post"},{"authors":["YoungWilliam"],"categories":["Hexo"],"content":"  本文用于记录以及简单的安装\n 目录 HAHAHUGOSHORTCODE-TOC0-HBHB\n简单介绍 HexoEditor 是 Github 上一款开源的 Markdown 编辑器。\n引用原作者说的话： \u0026gt; 这是一款为 Hexo 做了优化的 Markdown 编辑器。 使用 Electron 做框架 修改自 Moeditor, 我只是为了让他更好的去为 Hexo 下的博客更好的去书写内容。\n同时它还包括很多功能，其中我觉得最有用的就是： \u0026gt; 预览内容与 Hexo 生成页面内容高度相似\n更多详情介绍请点击这里。\n安装过程 整个过程参照官方文档。\n1.准备工作 安装 git  Download Page for Mac OS X Download Page for Windows Download Page for Linux/Unix  安装 nodejs  Download Page (English) 下载地址 (中文)  2.下载配置 Hexo 3.设置 npm 缓存路径 Windows 下 npm config set prefix \u0026quot;C:/Program Files/nodejs/npm_global\u0026quot; npm config set cache \u0026quot;C:/Program Files/nodejs/npm_cache\u0026quot;  Linux\\Mac 下 npm config set prefix \u0026quot;~/nodejs/npm_global\u0026quot; npm config set cache \u0026quot;~/nodejs/npm_cache\u0026quot;  注意：这里的路径是你安装 nodejs 的子目录下对应的路径\n4.设置下载来源（镜像），加速下载 来自原作者好心提醒： 在中国，你应该设置淘宝镜像来加速下载。(PS: 这个我没试过，我是直接通过代理的)\nnpm config set registry \u0026quot;https://registry.npm.taobao.org/\u0026quot; npm config set electron_mirror \u0026quot;https://npm.taobao.org/mirrors/electron/\u0026quot;  5.下载 GitHub 上最新的版本并安装 git clone https://github.com/zhuzhuyule/HexoEditor.git cd HexoEditor npm install  6.启动 npm start  然后，当当当，启动啦~\n设置快捷方式 在 HexoEditor 子目录下，新建 start.sh ，编辑（右键-\u0026gt;打开方式-\u0026gt;NotePad++），输入（其实就是启动）\nnpm start  保存，退出，双击一下 start.sh ，看看效果如何~ 顺利的话，gitbash 会弹出来，然后 HexoEditor就会弹出来了~\n本教程到此就结束了，希望大家玩的开心~\n","date":1529820480,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1529820480,"objectID":"ca9ef4d95e27827c9683fd92051e9844","permalink":"https://youngwilliamz.github.io/post/hexoeditor/","publishdate":"2018-06-24T06:08:00Z","relpermalink":"/post/hexoeditor/","section":"post","summary":"不了解一下？","tags":["编辑器","Hexo","Markdown"],"title":"HexoEditor, 一个写 Hexo 非常好用的 Markdown 编辑器","type":"post"}]