<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSAPP | New World</title>
    <link>https://youngwilliamz.github.io/tags/csapp/</link>
      <atom:link href="https://youngwilliamz.github.io/tags/csapp/index.xml" rel="self" type="application/rss+xml" />
    <description>CSAPP</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><lastBuildDate>Sun, 22 Sep 2019 21:01:13 +0800</lastBuildDate>
    <image>
      <url>https://youngwilliamz.github.io/img/icon-192.png</url>
      <title>CSAPP</title>
      <link>https://youngwilliamz.github.io/tags/csapp/</link>
    </image>
    
    <item>
      <title>CSAPP 笔记 第三章《程序的机器级表示》</title>
      <link>https://youngwilliamz.github.io/post/csapp-note-3/</link>
      <pubDate>Sun, 22 Sep 2019 21:01:13 +0800</pubDate>
      <guid>https://youngwilliamz.github.io/post/csapp-note-3/</guid>
      <description>

&lt;p&gt;本章的 &lt;code&gt;3.7&lt;/code&gt; 节重点讲解了函数的调用过程在机器级的表示。&lt;/p&gt;

&lt;p&gt;在 3.7 节之前，主要讲解的是汇编语句的格式、顺序执行、跳转控制。&lt;/p&gt;

&lt;h2 id=&#34;过程&#34;&gt;过程&lt;/h2&gt;

&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;

&lt;p&gt;不同的编程语言中，过程的形式不同：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数 (function)&lt;/li&gt;
&lt;li&gt;方法 (method)&lt;/li&gt;
&lt;li&gt;子例程 (subroutine)&lt;/li&gt;
&lt;li&gt;处理函数 (handler)等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但他们都有的共有特性。&lt;/p&gt;

&lt;p&gt;要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程 p 调用过程 Q, Q 执行后返回到 P。这些动作包括下面一个或多个机制:
1. &lt;strong&gt;传递控制。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然 后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;传递数据&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;P 必须能够向 Q 提供一个或多个参数， Q 必须能够向 P 返回一个值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;分配和释放内存&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在开始时， Q 可能需要为局部变量分配空间，而在返回前，又必须
   释放这些存储空间。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSAPP 笔记 第二章《信息的表示和处理》</title>
      <link>https://youngwilliamz.github.io/post/csapp-note-2/</link>
      <pubDate>Sun, 08 Sep 2019 20:56:59 +0800</pubDate>
      <guid>https://youngwilliamz.github.io/post/csapp-note-2/</guid>
      <description>

&lt;p&gt;这章的内容非常基础并且重要，但为了节省篇幅，此篇笔记仅记录笔者不熟的或者认为非常重要且易出错的知识点。&lt;/p&gt;

&lt;h2 id=&#34;为什么要用-二进制&#34;&gt;为什么要用「二进制」？&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;二值信号能够很容易地被表示、存储和传输，例如，可以表 示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对 二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在 一 个单独的硅片 上集成数百万甚至数十亿个这样的电路。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;little-endian-小端-和-big-endian-大端&#34;&gt;&amp;ldquo;little endian(小端)&amp;ldquo;和 &amp;ldquo;big endian(大端)&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;最低有效字节在最前面的方式，称为小端法 (little endian) 。&lt;/p&gt;

&lt;p&gt;最高有效字节在最前面的方式，称为大端法 (big endian) 。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;假设变量 x 的类型为 int ，位于地址 0x100 处，它的十六进制值为Ox01234567。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;0x100&lt;/th&gt;
&lt;th&gt;0x101&lt;/th&gt;
&lt;th&gt;0x102&lt;/th&gt;
&lt;th&gt;0x103&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;大端&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;小端&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>CSAPP 笔记 第一章《计算机系统漫游》</title>
      <link>https://youngwilliamz.github.io/post/csapp-note-1/</link>
      <pubDate>Sun, 01 Sep 2019 22:40:06 +0800</pubDate>
      <guid>https://youngwilliamz.github.io/post/csapp-note-1/</guid>
      <description>

&lt;p&gt;最近开始忙秋招，「码农翻身」公众号及同名书的作者老刘在知识星球里举办了读《CSAPP》的活动，之前一直没啃下来，希望能够借此机会逼自己一把，把这本厚厚的经典看完，并好好写笔记。&lt;/p&gt;

&lt;p&gt;计算机系统 = 硬件 + 系统软件&lt;/p&gt;

&lt;p&gt;作者如是说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“如果你全力投身学习本书中的概念，完全理解底 层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛&amp;rdquo;的道路。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看完这本书你将会学到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;实践技巧&lt;/li&gt;
&lt;li&gt;优化代码小窍门&lt;/li&gt;
&lt;li&gt;了解编译器如何实现&lt;/li&gt;
&lt;li&gt;如何识别和避免连接时那些令人讨厌的错误&lt;/li&gt;
&lt;li&gt;如何编写自己的 Unix shell&lt;/li&gt;
&lt;li&gt;认识并发的陷阱&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-信息就是-位-上下文&#34;&gt;1. 信息就是「位+上下文」&lt;/h2&gt;

&lt;p&gt;hello 程序生命周期开端：hel lo.c 源文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由2进制的 ASCII 编码后的字符组成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文本文件：只有ASCII字符构成的文件。如：hello.c&lt;/p&gt;

&lt;p&gt;二进制文件：非文本文件。&lt;/p&gt;

&lt;p&gt;因此，在计算机的世界中，所有的信息都是由一串比特表示。&lt;/p&gt;

&lt;p&gt;区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。&lt;/p&gt;

&lt;h2 id=&#34;2-程序被其他程序翻译成不同的格式&#34;&gt;2. 程序被其他程序翻译成不同的格式&lt;/h2&gt;

&lt;p&gt;hello 程序生命周期：可执行文件，或者叫「目标程序」&lt;/p&gt;

&lt;p&gt;编译器驱动程序：能够将「源文件」转化「目标文件」，如&lt;code&gt;gcc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;linux&amp;gt; gee -o hello hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一过程又叫翻译，可分为四个阶段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./image/CSAPP1-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;执行这四个阶段的程序一起构成「编译系统」(compilation system)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;预处理阶段：修改源文件，得到另一个 C 程序。

&lt;ul&gt;
&lt;li&gt;删除部分#开头的命令&lt;/li&gt;
&lt;li&gt;插入一些系统头文件，如&lt;code&gt;stdio.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编译阶段：翻译成汇编文本文件。&lt;/li&gt;
&lt;li&gt;汇编阶段：将汇编文本文件翻译成机器语言指令，并打包成「可重定位目标程序」(relocatable object program)的格式。&lt;/li&gt;
&lt;li&gt;链接阶段：合并一些调用的头文件，得到最终的可执行文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-了解编译系统如何工作&#34;&gt;3. 了解编译系统如何工作&lt;/h2&gt;

&lt;p&gt;程序员必须知道编译系统如何工作的重要原因：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优化程序性能&lt;/li&gt;
&lt;li&gt;理解连接时出现的错误&lt;/li&gt;
&lt;li&gt;避免安全漏洞&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-处理器读并解释储存在内存中的指令&#34;&gt;4. 处理器读并解释储存在内存中的指令&lt;/h2&gt;

&lt;p&gt;系统的硬件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总线（BUS）

&lt;ul&gt;
&lt;li&gt;贯穿整个系统的一组电子管道&lt;/li&gt;
&lt;li&gt;通常总线被设计成传送定长的字节块，也就是字 (word)。字长是一个基本的系统参数，一般为 4 个字节( 32 位）或者 8 个字节（64位）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;I/O设备

&lt;ul&gt;
&lt;li&gt;系统与外部世界的联系通道。&lt;/li&gt;
&lt;li&gt;每个I/O设备都通过一个控制器或适配器与I/O总线相连。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;主存(Main Memory)

&lt;ul&gt;
&lt;li&gt;临时存储设备&lt;/li&gt;
&lt;li&gt;物理上：动态随机存取储存器(DRAM)。&lt;/li&gt;
&lt;li&gt;逻辑上：线性字节数组，每个字节都有其唯一的地址。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;处理器（CPU）

&lt;ul&gt;
&lt;li&gt;解释(或执行)存储在主存中指令的引擎&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行 hello 文件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在 shell 中输入&lt;code&gt;./hello&lt;/code&gt; 之后，shell 程序将字符逐一读入寄存器，再把它放入内存。&lt;/li&gt;
&lt;li&gt;回车后，shell知道输入完成，开始执行一系列指令来加载可执行的 hello 文件。&lt;/li&gt;
&lt;li&gt;这些指令将 hello 目标文件从磁盘复制到内存中。&lt;/li&gt;
&lt;li&gt;处理器将目标文件中的机器语言指令复制到寄存器中，开始解析里面的指令并执行。&lt;/li&gt;
&lt;li&gt;数据被现实在屏幕上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：利用 DMA 技术可以不通过处理器而直接从磁盘到达主存。&lt;/p&gt;

&lt;h2 id=&#34;5-高速缓存至关重要&#34;&gt;5. 高速缓存至关重要&lt;/h2&gt;

&lt;p&gt;上一个运行 hello 程序的例子中，信息需要依次经过：磁盘，主存，寄存器。&lt;/p&gt;

&lt;p&gt;这样会造成开销，减慢程序。&lt;/p&gt;

&lt;p&gt;因此，需要使得这些复制操作尽可能快的完成。&lt;/p&gt;

&lt;h2 id=&#34;6-储存设备形成层次结构&#34;&gt;6 储存设备形成层次结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;./image/CSAPP1-9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-操作系统管理硬件&#34;&gt;7 操作系统管理硬件&lt;/h2&gt;

&lt;p&gt;操作系统：应用程序和硬件之间插入的一层软件。&lt;/p&gt;

&lt;p&gt;操作系统两大基本功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;
&lt;li&gt;向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;操作系统提供三种基本的抽象：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;文件是对I/O设备的抽象&lt;/li&gt;
&lt;li&gt;虚拟内存是对主存和磁盘的抽象&lt;/li&gt;
&lt;li&gt;进程是处理器、主存和I/O设备的抽象&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;8-系统之间利用网络通信&#34;&gt;8 系统之间利用网络通信&lt;/h2&gt;

&lt;p&gt;网络可视为一个I/O设备。&lt;/p&gt;

&lt;h2 id=&#34;9-重要主题&#34;&gt;9 重要主题&lt;/h2&gt;

&lt;p&gt;Amdahl定律：&lt;/p&gt;

&lt;p&gt;并发和并行&lt;/p&gt;

&lt;p&gt;计算机抽象&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
