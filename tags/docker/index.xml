<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker | New World</title>
    <link>https://youngwilliamz.github.io/tags/docker/</link>
      <atom:link href="https://youngwilliamz.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <description>docker</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><lastBuildDate>Tue, 01 Oct 2019 03:16:51 +0800</lastBuildDate>
    <image>
      <url>https://youngwilliamz.github.io/img/icon-192.png</url>
      <title>docker</title>
      <link>https://youngwilliamz.github.io/tags/docker/</link>
    </image>
    
    <item>
      <title>群晖系统中为 Jellyfin 开启硬件加速(Quick Sync Video)</title>
      <link>https://youngwilliamz.github.io/post/enable-quick-sync-video-for-jellyfin-on-docker-of-synology/</link>
      <pubDate>Tue, 01 Oct 2019 03:16:51 +0800</pubDate>
      <guid>https://youngwilliamz.github.io/post/enable-quick-sync-video-for-jellyfin-on-docker-of-synology/</guid>
      <description>

&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;

&lt;p&gt;最近折腾群晖，发现 &lt;code&gt;Jellyfin&lt;/code&gt; 这个玩具，可以解决用网页看视频的需求。&lt;/p&gt;

&lt;p&gt;折腾的途中发现有硬件加速的功能，然后发现确实有些编码格式的视频播放的时候CPU占用很高。&lt;/p&gt;

&lt;p&gt;看了一些&lt;a href=&#34;http://tech.feng.com/2015-12-23/Synology_DiskStation_DS716+_FengLab_2.shtml&#34; target=&#34;_blank&#34;&gt;评测&lt;/a&gt;之后发现硬件加速可以很大程度上提升视频解码的能力，同时CPU占用不会很高。&lt;/p&gt;

&lt;p&gt;然后发现我的 U，&lt;code&gt;J1900&lt;/code&gt; 在 &lt;a href=&#34;https://ark.intel.com/content/www/us/en/ark/products/78867/intel-celeron-processor-j1900-2m-cache-up-to-2-42-ghz.html&#34; target=&#34;_blank&#34;&gt;Intel 官网的介绍&lt;/a&gt; 中是支持 &lt;code&gt;Quick Sync Video&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;于是开始了新一轮的折腾之路。&lt;/p&gt;

&lt;h2 id=&#34;过程&#34;&gt;过程&lt;/h2&gt;

&lt;p&gt;查阅一些资料之后发现，起硬件加速作用的主要是 &lt;code&gt;/dev/dri&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在映射 &lt;code&gt;/dev/dri&lt;/code&gt; 到 docker 之后，选择 Jellyfin 硬件加速的 &lt;code&gt;Intel Quick Sync Video&lt;/code&gt; 选项发现CPU的占用率几乎没有改变。这是怎么回事？&lt;/p&gt;

&lt;p&gt;正百思不得其解时，突然在&lt;a href=&#34;https://www.reddit.com/r/jellyfin/comments/bgbkye/trancoding_in_docker_using_qnap_nas_with_intel/&#34; target=&#34;_blank&#34;&gt;论坛&lt;/a&gt;中发现 &lt;code&gt;Intel Quick Sync Video&lt;/code&gt; 选项只对 &lt;code&gt;Windows&lt;/code&gt; 的版本有用。 &lt;code&gt;Linux&lt;/code&gt; 都是统一用 &lt;code&gt;VA API&lt;/code&gt; 这个选项。&lt;/p&gt;

&lt;h2 id=&#34;结果&#34;&gt;结果&lt;/h2&gt;

&lt;p&gt;在使用硬件加速之后，确实效果有提升，而且CPU占用是肉眼可见的降低了，由原来的 99% 降低到 50%。播放也不卡顿了。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://wildestpixel.co.uk/enabling-quick-sync-video-on-handbrake-for-docker-on-synology/&#34; target=&#34;_blank&#34;&gt;Enabling Quick Sync Video on Handbrake for Docker on Synology&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/jellyfin/comments/bgbkye/trancoding_in_docker_using_qnap_nas_with_intel/&#34; target=&#34;_blank&#34;&gt;https://www.reddit.com/r/jellyfin/comments/bgbkye/trancoding_in_docker_using_qnap_nas_with_intel/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ark.intel.com/content/www/us/en/ark/products/78867/intel-celeron-processor-j1900-2m-cache-up-to-2-42-ghz.html)&#34; target=&#34;_blank&#34;&gt;https://ark.intel.com/content/www/us/en/ark/products/78867/intel-celeron-processor-j1900-2m-cache-up-to-2-42-ghz.html)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>从 0 实现 Docker</title>
      <link>https://youngwilliamz.github.io/project/mydocker/</link>
      <pubDate>Sun, 11 Aug 2019 01:49:46 +0800</pubDate>
      <guid>https://youngwilliamz.github.io/project/mydocker/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Docker 背后： Linux 的 /proc</title>
      <link>https://youngwilliamz.github.io/post/linux-proc/</link>
      <pubDate>Fri, 02 Aug 2019 02:04:09 +0000</pubDate>
      <guid>https://youngwilliamz.github.io/post/linux-proc/</guid>
      <description>

&lt;h2 id=&#34;为什么要有-proc&#34;&gt;为什么要有 &lt;code&gt;/proc&lt;/code&gt;？&lt;/h2&gt;

&lt;p&gt;想必在日常开发&lt;del&gt;写&lt;/del&gt;查 BUG 中，你会经常用到像 &lt;code&gt;top&lt;/code&gt;、&lt;code&gt;ps&lt;/code&gt; 这样的 Linux 命令来查看进程、CPU 的状态吧。&lt;/p&gt;

&lt;p&gt;那你是否有想过：这些不都是内核才知道的吗？而作为身处 shell （用户态）的我们又是通过什么途径知道这些的呢？&lt;/p&gt;

&lt;p&gt;是有什么 system call 吗？是有什么高级的接口吗？&lt;/p&gt;

&lt;p&gt;不不不，其实是通过一个神奇的目录，也就是今天的主角 &lt;code&gt;/proc&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;实际上，&lt;code&gt;top&lt;/code&gt; 中的数据就是读取 &lt;code&gt;/proc/stat&lt;/code&gt; 文件获得的，&lt;code&gt;/proc/stat&lt;/code&gt; 文件被读取时会自动更新，从而 &lt;code&gt;top&lt;/code&gt; 获得最新的 CPU 占用率情况。&lt;/p&gt;

&lt;h2 id=&#34;proc-是什么&#34;&gt;&lt;code&gt;/proc&lt;/code&gt; 是什么？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt; 其实不是一个“真正”的文件目录，而是一个“虚拟”的文件系统（virtual filesystem）。&lt;/p&gt;

&lt;p&gt;为什么是虚拟的呢？因为它不写入&lt;strong&gt;外存&lt;/strong&gt;空间，只存在于&lt;strong&gt;内存&lt;/strong&gt;中。&lt;/p&gt;

&lt;p&gt;它包含了系统运行时的信息，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前运行进程信息&lt;/li&gt;
&lt;li&gt;系统内存&lt;/li&gt;
&lt;li&gt;mount 设备信息&lt;/li&gt;
&lt;li&gt;一些硬件配置&lt;/li&gt;
&lt;li&gt;&amp;hellip;等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，可以把它当作&lt;strong&gt;内核&lt;/strong&gt;的信息中心。&lt;/p&gt;

&lt;p&gt;当然许多系统工具都是通过简单读取该目录下的某些内容。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;lsmod&lt;/code&gt; = &lt;code&gt;cat /proc/modules&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lspci&lt;/code&gt; = &lt;code&gt;cat /proc/pci&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在系统正在运行时，你甚至可以通过修改 &lt;code&gt;/proc&lt;/code&gt; 目录下文件，来读取修改系统的内核参数（sysctl）。&lt;/p&gt;

&lt;h2 id=&#34;proc-基本目录结构&#34;&gt;&lt;code&gt;/proc&lt;/code&gt; 基本目录结构&lt;/h2&gt;

&lt;p&gt;因为文件都在内存中，如果你去看每个文件的大小，你会发现都是 0，除了 &lt;code&gt;kcore&lt;/code&gt;, &lt;code&gt;mtrr&lt;/code&gt; and &lt;code&gt;self&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当遍历这个目录的时候，会发现有些数字，这些都是为每个进程创建的空间，数字就是它们的 PID。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[go_dev@0f8b372ed635 proc]$ ll /proc
total 0
dr-xr-xr-x  9 go_dev go_dev     0 Aug  1 18:43 1
dr-xr-xr-x  9 go_dev go_dev     0 Aug  1 18:44 30
drwxrwxrwt  2 root   root      40 Aug  1 18:43 acpi
-r--r--r--  1 root   root       0 Aug  1 18:44 buddyinfo
dr-xr-xr-x  4 root   root       0 Aug  1 18:43 bus
-r--r--r--  1 root   root       0 Aug  1 18:44 cgroups
-r--r--r--  1 root   root       0 Aug  1 18:44 cmdline
-r--r--r--  1 root   root   23709 Aug  1 18:44 config.gz
-r--r--r--  1 root   root       0 Aug  1 18:44 consoles
-r--r--r--  1 root   root       0 Aug  1 18:44 cpuinfo
-r--r--r--  1 root   root       0 Aug  1 18:44 crypto
-r--r--r--  1 root   root       0 Aug  1 18:44 devices
-r--r--r--  1 root   root       0 Aug  1 18:44 diskstats
-r--r--r--  1 root   root       0 Aug  1 18:44 dma
dr-xr-xr-x  2 root   root       0 Aug  1 18:44 driver
-r--r--r--  1 root   root       0 Aug  1 18:44 execdomains
-r--r--r--  1 root   root       0 Aug  1 18:44 fb
-r--r--r--  1 root   root       0 Aug  1 18:44 filesystems
dr-xr-xr-x  8 root   root       0 Aug  1 18:43 fs
-r--r--r--  1 root   root       0 Aug  1 18:44 interrupts
-r--r--r--  1 root   root       0 Aug  1 18:44 iomem
-r--r--r--  1 root   root       0 Aug  1 18:44 ioports
dr-xr-xr-x 31 root   root       0 Aug  1 18:43 irq
-r--r--r--  1 root   root       0 Aug  1 18:44 kallsyms
crw-rw-rw-  1 root   root    1, 3 Aug  1 18:43 kcore
-r--r--r--  1 root   root       0 Aug  1 18:44 key-users
crw-rw-rw-  1 root   root    1, 3 Aug  1 18:43 keys
-r--------  1 root   root       0 Aug  1 18:44 kmsg
-r--------  1 root   root       0 Aug  1 18:44 kpagecgroup
-r--------  1 root   root       0 Aug  1 18:44 kpagecount
-r--------  1 root   root       0 Aug  1 18:44 kpageflags
-r--r--r--  1 root   root       0 Aug  1 18:44 loadavg
-r--r--r--  1 root   root       0 Aug  1 18:44 locks
-r--r--r--  1 root   root       0 Aug  1 18:44 meminfo
-r--r--r--  1 root   root       0 Aug  1 18:44 misc
-r--r--r--  1 root   root       0 Aug  1 18:44 modules
lrwxrwxrwx  1 root   root      11 Aug  1 18:44 mounts -&amp;gt; self/mounts
dr-xr-xr-x  2 root   root       0 Aug  1 18:44 mpt
-rw-r--r--  1 root   root       0 Aug  1 18:44 mtrr
lrwxrwxrwx  1 root   root       8 Aug  1 18:44 net -&amp;gt; self/net
-r--r--r--  1 root   root       0 Aug  1 18:44 pagetypeinfo
-r--r--r--  1 root   root       0 Aug  1 18:44 partitions
crw-rw-rw-  1 root   root    1, 3 Aug  1 18:43 sched_debug
lrwxrwxrwx  1 root   root       0 Aug  1 18:43 self -&amp;gt; 30
-rw-------  1 root   root       0 Aug  1 18:44 slabinfo
-r--r--r--  1 root   root       0 Aug  1 18:44 softirqs
-r--r--r--  1 root   root       0 Aug  1 18:44 stat
-r--r--r--  1 root   root       0 Aug  1 18:44 swaps
dr-xr-xr-x  1 root   root       0 Aug  1 18:43 sys
--w-------  1 root   root       0 Aug  1 18:43 sysrq-trigger
dr-xr-xr-x  2 root   root       0 Aug  1 18:44 sysvipc
lrwxrwxrwx  1 root   root       0 Aug  1 18:43 thread-self -&amp;gt; 30/task/30
crw-rw-rw-  1 root   root    1, 3 Aug  1 18:43 timer_list
dr-xr-xr-x  4 root   root       0 Aug  1 18:44 tty
-r--r--r--  1 root   root       0 Aug  1 18:44 uptime
-r--r--r--  1 root   root       0 Aug  1 18:44 version
-r--------  1 root   root       0 Aug  1 18:44 vmallocinfo
-r--r--r--  1 root   root       0 Aug  1 18:44 vmstat
-r--r--r--  1 root   root       0 Aug  1 18:44 zoneinfo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此介绍几个比较重要的部分：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;/proc/N&lt;/th&gt;
&lt;th&gt;PID 为 N 的进程信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/proc/N/cmdline&lt;/td&gt;
&lt;td&gt;进程启动命令&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/cwd&lt;/td&gt;
&lt;td&gt;链接到进程当前工作目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/environ&lt;/td&gt;
&lt;td&gt;进程环境变量列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/exe&lt;/td&gt;
&lt;td&gt;链接到进程的执行命令文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/fd&lt;/td&gt;
&lt;td&gt;包含进程相关的所有文件描述符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/maps&lt;/td&gt;
&lt;td&gt;与进程相关的内存映射信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/mem&lt;/td&gt;
&lt;td&gt;指代进程持有的内存，不可读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/root&lt;/td&gt;
&lt;td&gt;链接到进程的根目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/stat&lt;/td&gt;
&lt;td&gt;进程的状态&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/statm&lt;/td&gt;
&lt;td&gt;进程使用的内存状态&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/N/status&lt;/td&gt;
&lt;td&gt;进程状态信息，比 stat/statm 更具可读性&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/self/&lt;/td&gt;
&lt;td&gt;链接到当前正在运行的进程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果像了解更多的话，请自行 google 或者看看 &lt;a href=&#34;https://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html&#34; target=&#34;_blank&#34;&gt;Linux Filesystem Hierarchy: 1.14. /proc&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;docker-如何利用到-proc&#34;&gt;Docker 如何利用到 &lt;code&gt;/proc&lt;/code&gt;？&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html&#34; target=&#34;_blank&#34;&gt;Linux Filesystem Hierarchy: 1.14. /proc&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/27082348/&#34; target=&#34;_blank&#34;&gt;《自己动手写Docker》&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Procfs&#34; target=&#34;_blank&#34;&gt;wiki: procfs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
